# @generated by codegen. DO NOT EDIT BY HAND

from __future__ import annotations
from typing import Any, Dict, List, Optional
from enum import Enum
from pydantic import BaseModel, Field, ConfigDict


# Base class with shared configuration
class TurnkeyBaseModel(BaseModel):
    model_config = ConfigDict(populate_by_name=True)


# --- Base Types from Swagger Definitions ---


class apiApiKeyParams(TurnkeyBaseModel):
    apiKeyName: str = Field(description="Human-readable name for an API Key.")
    publicKey: str = Field(
        description="The public component of a cryptographic key pair used to sign messages and transactions."
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Optional window (in seconds) indicating how long the API Key should last.",
    )


class billingActivateBillingTierIntent(TurnkeyBaseModel):
    productId: str = Field(
        description="The product that the customer wants to subscribe to."
    )


class billingActivateBillingTierResult(TurnkeyBaseModel):
    productId: str = Field(description="The id of the product being subscribed to.")


class billingDeletePaymentMethodIntent(TurnkeyBaseModel):
    paymentMethodId: str = Field(
        description="The payment method that the customer wants to remove."
    )


class billingDeletePaymentMethodResult(TurnkeyBaseModel):
    paymentMethodId: str = Field(description="The payment method that was removed.")


class billingSetPaymentMethodIntent(TurnkeyBaseModel):
    number: str = Field(description="The account number of the customer's credit card.")
    cvv: str = Field(
        description="The verification digits of the customer's credit card."
    )
    expiryMonth: str = Field(description="The month that the credit card expires.")
    expiryYear: str = Field(description="The year that the credit card expires.")
    cardHolderEmail: str = Field(
        description="The email that will receive invoices for the credit card."
    )
    cardHolderName: str = Field(description="The name associated with the credit card.")


class billingSetPaymentMethodIntentV2(TurnkeyBaseModel):
    paymentMethodId: str = Field(
        description="The id of the payment method that was created clientside."
    )
    cardHolderEmail: str = Field(
        description="The email that will receive invoices for the credit card."
    )
    cardHolderName: str = Field(description="The name associated with the credit card.")


class billingSetPaymentMethodResult(TurnkeyBaseModel):
    lastFour: str = Field(description="The last four digits of the credit card added.")
    cardHolderName: str = Field(
        description="The name associated with the payment method."
    )
    cardHolderEmail: str = Field(
        description="The email address associated with the payment method."
    )


class datav1Tag(TurnkeyBaseModel):
    tagId: str = Field(description="Unique identifier for a given Tag.")
    tagName: str = Field(description="Human-readable name for a Tag.")
    tagType: v1TagType
    createdAt: externaldatav1Timestamp
    updatedAt: externaldatav1Timestamp


class externalactivityv1PolicyEvaluation(TurnkeyBaseModel):
    id: str = Field(description="Unique identifier for a given policy evaluation.")
    activityId: str = Field(description="Unique identifier for a given Activity.")
    organizationId: str = Field(
        description="Unique identifier for the Organization the Activity belongs to."
    )
    voteId: str = Field(
        description="Unique identifier for the Vote associated with this policy evaluation."
    )
    policyEvaluations: List[immutablecommonv1PolicyEvaluation] = Field(
        description="Detailed evaluation result for each Policy that was run."
    )
    createdAt: externaldatav1Timestamp


class externaldatav1Address(TurnkeyBaseModel):
    format: Optional[v1AddressFormat] = Field(default=None)
    address: Optional[str] = Field(default=None)


class externaldatav1Credential(TurnkeyBaseModel):
    publicKey: str = Field(
        description="The public component of a cryptographic key pair used to sign messages and transactions."
    )
    type: v1CredentialType


class externaldatav1Quorum(TurnkeyBaseModel):
    threshold: int = Field(
        description="Count of unique approvals required to meet quorum."
    )
    userIds: List[str] = Field(description="Unique identifiers of quorum set members.")


class externaldatav1SignatureScheme(str, Enum):
    SIGNATURE_SCHEME_EPHEMERAL_KEY_P256 = "SIGNATURE_SCHEME_EPHEMERAL_KEY_P256"


class externaldatav1SmartContractInterface(TurnkeyBaseModel):
    organizationId: str = Field(
        description="The Organization the Smart Contract Interface belongs to."
    )
    smartContractInterfaceId: str = Field(
        description="Unique identifier for a given Smart Contract Interface (ABI or IDL)."
    )
    smartContractAddress: str = Field(
        description="The address corresponding to the Smart Contract or Program."
    )
    smartContractInterface: str = Field(
        description="The JSON corresponding to the Smart Contract Interface (ABI or IDL)."
    )
    type: str = Field(
        description="The type corresponding to the Smart Contract Interface (either ETHEREUM or SOLANA)."
    )
    label: str = Field(
        description="The label corresponding to the Smart Contract Interface (either ETHEREUM or SOLANA)."
    )
    notes: str = Field(
        description="The notes corresponding to the Smart Contract Interface (either ETHEREUM or SOLANA)."
    )
    createdAt: externaldatav1Timestamp
    updatedAt: externaldatav1Timestamp


class externaldatav1Timestamp(TurnkeyBaseModel):
    seconds: str
    nanos: str


class immutableactivityv1Address(TurnkeyBaseModel):
    format: Optional[v1AddressFormat] = Field(default=None)
    address: Optional[str] = Field(default=None)


class immutablecommonv1PolicyEvaluation(TurnkeyBaseModel):
    policyId: Optional[str] = Field(default=None)
    outcome: Optional[v1Outcome] = Field(default=None)


class protobufAny(TurnkeyBaseModel):
    type: Optional[str] = Field(default=None, alias="@type")


class rpcStatus(TurnkeyBaseModel):
    code: Optional[int] = Field(default=None)
    message: Optional[str] = Field(default=None)
    details: Optional[List[protobufAny]] = Field(default=None)


class v1AcceptInvitationIntent(TurnkeyBaseModel):
    invitationId: str = Field(
        description="Unique identifier for a given Invitation object."
    )
    userId: str = Field(description="Unique identifier for a given User.")
    authenticator: v1AuthenticatorParams = Field(
        description="WebAuthN hardware devices that can be used to log in to the Turnkey web app."
    )


class v1AcceptInvitationIntentV2(TurnkeyBaseModel):
    invitationId: str = Field(
        description="Unique identifier for a given Invitation object."
    )
    userId: str = Field(description="Unique identifier for a given User.")
    authenticator: v1AuthenticatorParamsV2 = Field(
        description="WebAuthN hardware devices that can be used to log in to the Turnkey web app."
    )


class v1AcceptInvitationResult(TurnkeyBaseModel):
    invitationId: str = Field(description="Unique identifier for a given Invitation.")
    userId: str = Field(description="Unique identifier for a given User.")


class v1AccessType(str, Enum):
    ACCESS_TYPE_WEB = "ACCESS_TYPE_WEB"
    ACCESS_TYPE_API = "ACCESS_TYPE_API"
    ACCESS_TYPE_ALL = "ACCESS_TYPE_ALL"


class v1Activity(TurnkeyBaseModel):
    id: str = Field(description="Unique identifier for a given Activity object.")
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    status: v1ActivityStatus = Field(
        description="The current processing status of a specified Activity."
    )
    type: v1ActivityType = Field(
        description="Type of Activity, such as Add User, or Sign Transaction."
    )
    intent: v1Intent = Field(
        description="Intent object crafted by Turnkey based on the user request, used to assess the permissibility of an action."
    )
    result: v1Result = Field(description="Result of the intended action.")
    votes: List[v1Vote] = Field(
        description="A list of objects representing a particular User's approval or rejection of a Consensus request, including all relevant metadata."
    )
    appProofs: Optional[List[v1AppProof]] = Field(
        default=None,
        description="A list of App Proofs generated by enclaves during activity execution, providing verifiable attestations of performed operations.",
    )
    fingerprint: str = Field(description="An artifact verifying a User's action.")
    canApprove: bool
    canReject: bool
    createdAt: externaldatav1Timestamp
    updatedAt: externaldatav1Timestamp
    failure: Optional[rpcStatus] = Field(
        default=None, description="Failure reason of the intended action."
    )


class v1ActivityResponse(TurnkeyBaseModel):
    activity: v1Activity = Field(
        description="An action that can be taken within the Turnkey infrastructure."
    )


class v1ActivityStatus(str, Enum):
    ACTIVITY_STATUS_CREATED = "ACTIVITY_STATUS_CREATED"
    ACTIVITY_STATUS_PENDING = "ACTIVITY_STATUS_PENDING"
    ACTIVITY_STATUS_COMPLETED = "ACTIVITY_STATUS_COMPLETED"
    ACTIVITY_STATUS_FAILED = "ACTIVITY_STATUS_FAILED"
    ACTIVITY_STATUS_CONSENSUS_NEEDED = "ACTIVITY_STATUS_CONSENSUS_NEEDED"
    ACTIVITY_STATUS_REJECTED = "ACTIVITY_STATUS_REJECTED"


class v1ActivityType(str, Enum):
    ACTIVITY_TYPE_CREATE_API_KEYS = "ACTIVITY_TYPE_CREATE_API_KEYS"
    ACTIVITY_TYPE_CREATE_USERS = "ACTIVITY_TYPE_CREATE_USERS"
    ACTIVITY_TYPE_CREATE_PRIVATE_KEYS = "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS"
    ACTIVITY_TYPE_SIGN_RAW_PAYLOAD = "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD"
    ACTIVITY_TYPE_CREATE_INVITATIONS = "ACTIVITY_TYPE_CREATE_INVITATIONS"
    ACTIVITY_TYPE_ACCEPT_INVITATION = "ACTIVITY_TYPE_ACCEPT_INVITATION"
    ACTIVITY_TYPE_CREATE_POLICY = "ACTIVITY_TYPE_CREATE_POLICY"
    ACTIVITY_TYPE_DISABLE_PRIVATE_KEY = "ACTIVITY_TYPE_DISABLE_PRIVATE_KEY"
    ACTIVITY_TYPE_DELETE_USERS = "ACTIVITY_TYPE_DELETE_USERS"
    ACTIVITY_TYPE_DELETE_API_KEYS = "ACTIVITY_TYPE_DELETE_API_KEYS"
    ACTIVITY_TYPE_DELETE_INVITATION = "ACTIVITY_TYPE_DELETE_INVITATION"
    ACTIVITY_TYPE_DELETE_ORGANIZATION = "ACTIVITY_TYPE_DELETE_ORGANIZATION"
    ACTIVITY_TYPE_DELETE_POLICY = "ACTIVITY_TYPE_DELETE_POLICY"
    ACTIVITY_TYPE_CREATE_USER_TAG = "ACTIVITY_TYPE_CREATE_USER_TAG"
    ACTIVITY_TYPE_DELETE_USER_TAGS = "ACTIVITY_TYPE_DELETE_USER_TAGS"
    ACTIVITY_TYPE_CREATE_ORGANIZATION = "ACTIVITY_TYPE_CREATE_ORGANIZATION"
    ACTIVITY_TYPE_SIGN_TRANSACTION = "ACTIVITY_TYPE_SIGN_TRANSACTION"
    ACTIVITY_TYPE_APPROVE_ACTIVITY = "ACTIVITY_TYPE_APPROVE_ACTIVITY"
    ACTIVITY_TYPE_REJECT_ACTIVITY = "ACTIVITY_TYPE_REJECT_ACTIVITY"
    ACTIVITY_TYPE_DELETE_AUTHENTICATORS = "ACTIVITY_TYPE_DELETE_AUTHENTICATORS"
    ACTIVITY_TYPE_CREATE_AUTHENTICATORS = "ACTIVITY_TYPE_CREATE_AUTHENTICATORS"
    ACTIVITY_TYPE_CREATE_PRIVATE_KEY_TAG = "ACTIVITY_TYPE_CREATE_PRIVATE_KEY_TAG"
    ACTIVITY_TYPE_DELETE_PRIVATE_KEY_TAGS = "ACTIVITY_TYPE_DELETE_PRIVATE_KEY_TAGS"
    ACTIVITY_TYPE_SET_PAYMENT_METHOD = "ACTIVITY_TYPE_SET_PAYMENT_METHOD"
    ACTIVITY_TYPE_ACTIVATE_BILLING_TIER = "ACTIVITY_TYPE_ACTIVATE_BILLING_TIER"
    ACTIVITY_TYPE_DELETE_PAYMENT_METHOD = "ACTIVITY_TYPE_DELETE_PAYMENT_METHOD"
    ACTIVITY_TYPE_CREATE_POLICY_V2 = "ACTIVITY_TYPE_CREATE_POLICY_V2"
    ACTIVITY_TYPE_CREATE_POLICY_V3 = "ACTIVITY_TYPE_CREATE_POLICY_V3"
    ACTIVITY_TYPE_CREATE_API_ONLY_USERS = "ACTIVITY_TYPE_CREATE_API_ONLY_USERS"
    ACTIVITY_TYPE_UPDATE_ROOT_QUORUM = "ACTIVITY_TYPE_UPDATE_ROOT_QUORUM"
    ACTIVITY_TYPE_UPDATE_USER_TAG = "ACTIVITY_TYPE_UPDATE_USER_TAG"
    ACTIVITY_TYPE_UPDATE_PRIVATE_KEY_TAG = "ACTIVITY_TYPE_UPDATE_PRIVATE_KEY_TAG"
    ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2 = "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2"
    ACTIVITY_TYPE_CREATE_ORGANIZATION_V2 = "ACTIVITY_TYPE_CREATE_ORGANIZATION_V2"
    ACTIVITY_TYPE_CREATE_USERS_V2 = "ACTIVITY_TYPE_CREATE_USERS_V2"
    ACTIVITY_TYPE_ACCEPT_INVITATION_V2 = "ACTIVITY_TYPE_ACCEPT_INVITATION_V2"
    ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION = "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION"
    ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V2 = (
        "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V2"
    )
    ACTIVITY_TYPE_UPDATE_ALLOWED_ORIGINS = "ACTIVITY_TYPE_UPDATE_ALLOWED_ORIGINS"
    ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2 = "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2"
    ACTIVITY_TYPE_UPDATE_USER = "ACTIVITY_TYPE_UPDATE_USER"
    ACTIVITY_TYPE_UPDATE_POLICY = "ACTIVITY_TYPE_UPDATE_POLICY"
    ACTIVITY_TYPE_SET_PAYMENT_METHOD_V2 = "ACTIVITY_TYPE_SET_PAYMENT_METHOD_V2"
    ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V3 = (
        "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V3"
    )
    ACTIVITY_TYPE_CREATE_WALLET = "ACTIVITY_TYPE_CREATE_WALLET"
    ACTIVITY_TYPE_CREATE_WALLET_ACCOUNTS = "ACTIVITY_TYPE_CREATE_WALLET_ACCOUNTS"
    ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY = "ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY"
    ACTIVITY_TYPE_RECOVER_USER = "ACTIVITY_TYPE_RECOVER_USER"
    ACTIVITY_TYPE_SET_ORGANIZATION_FEATURE = "ACTIVITY_TYPE_SET_ORGANIZATION_FEATURE"
    ACTIVITY_TYPE_REMOVE_ORGANIZATION_FEATURE = (
        "ACTIVITY_TYPE_REMOVE_ORGANIZATION_FEATURE"
    )
    ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2 = "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2"
    ACTIVITY_TYPE_SIGN_TRANSACTION_V2 = "ACTIVITY_TYPE_SIGN_TRANSACTION_V2"
    ACTIVITY_TYPE_EXPORT_PRIVATE_KEY = "ACTIVITY_TYPE_EXPORT_PRIVATE_KEY"
    ACTIVITY_TYPE_EXPORT_WALLET = "ACTIVITY_TYPE_EXPORT_WALLET"
    ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V4 = (
        "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V4"
    )
    ACTIVITY_TYPE_EMAIL_AUTH = "ACTIVITY_TYPE_EMAIL_AUTH"
    ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT = "ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT"
    ACTIVITY_TYPE_INIT_IMPORT_WALLET = "ACTIVITY_TYPE_INIT_IMPORT_WALLET"
    ACTIVITY_TYPE_IMPORT_WALLET = "ACTIVITY_TYPE_IMPORT_WALLET"
    ACTIVITY_TYPE_INIT_IMPORT_PRIVATE_KEY = "ACTIVITY_TYPE_INIT_IMPORT_PRIVATE_KEY"
    ACTIVITY_TYPE_IMPORT_PRIVATE_KEY = "ACTIVITY_TYPE_IMPORT_PRIVATE_KEY"
    ACTIVITY_TYPE_CREATE_POLICIES = "ACTIVITY_TYPE_CREATE_POLICIES"
    ACTIVITY_TYPE_SIGN_RAW_PAYLOADS = "ACTIVITY_TYPE_SIGN_RAW_PAYLOADS"
    ACTIVITY_TYPE_CREATE_READ_ONLY_SESSION = "ACTIVITY_TYPE_CREATE_READ_ONLY_SESSION"
    ACTIVITY_TYPE_CREATE_OAUTH_PROVIDERS = "ACTIVITY_TYPE_CREATE_OAUTH_PROVIDERS"
    ACTIVITY_TYPE_DELETE_OAUTH_PROVIDERS = "ACTIVITY_TYPE_DELETE_OAUTH_PROVIDERS"
    ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V5 = (
        "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V5"
    )
    ACTIVITY_TYPE_OAUTH = "ACTIVITY_TYPE_OAUTH"
    ACTIVITY_TYPE_CREATE_API_KEYS_V2 = "ACTIVITY_TYPE_CREATE_API_KEYS_V2"
    ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION = "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION"
    ACTIVITY_TYPE_EMAIL_AUTH_V2 = "ACTIVITY_TYPE_EMAIL_AUTH_V2"
    ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V6 = (
        "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V6"
    )
    ACTIVITY_TYPE_DELETE_PRIVATE_KEYS = "ACTIVITY_TYPE_DELETE_PRIVATE_KEYS"
    ACTIVITY_TYPE_DELETE_WALLETS = "ACTIVITY_TYPE_DELETE_WALLETS"
    ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2 = (
        "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2"
    )
    ACTIVITY_TYPE_DELETE_SUB_ORGANIZATION = "ACTIVITY_TYPE_DELETE_SUB_ORGANIZATION"
    ACTIVITY_TYPE_INIT_OTP_AUTH = "ACTIVITY_TYPE_INIT_OTP_AUTH"
    ACTIVITY_TYPE_OTP_AUTH = "ACTIVITY_TYPE_OTP_AUTH"
    ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7 = (
        "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7"
    )
    ACTIVITY_TYPE_UPDATE_WALLET = "ACTIVITY_TYPE_UPDATE_WALLET"
    ACTIVITY_TYPE_UPDATE_POLICY_V2 = "ACTIVITY_TYPE_UPDATE_POLICY_V2"
    ACTIVITY_TYPE_CREATE_USERS_V3 = "ACTIVITY_TYPE_CREATE_USERS_V3"
    ACTIVITY_TYPE_INIT_OTP_AUTH_V2 = "ACTIVITY_TYPE_INIT_OTP_AUTH_V2"
    ACTIVITY_TYPE_INIT_OTP = "ACTIVITY_TYPE_INIT_OTP"
    ACTIVITY_TYPE_VERIFY_OTP = "ACTIVITY_TYPE_VERIFY_OTP"
    ACTIVITY_TYPE_OTP_LOGIN = "ACTIVITY_TYPE_OTP_LOGIN"
    ACTIVITY_TYPE_STAMP_LOGIN = "ACTIVITY_TYPE_STAMP_LOGIN"
    ACTIVITY_TYPE_OAUTH_LOGIN = "ACTIVITY_TYPE_OAUTH_LOGIN"
    ACTIVITY_TYPE_UPDATE_USER_NAME = "ACTIVITY_TYPE_UPDATE_USER_NAME"
    ACTIVITY_TYPE_UPDATE_USER_EMAIL = "ACTIVITY_TYPE_UPDATE_USER_EMAIL"
    ACTIVITY_TYPE_UPDATE_USER_PHONE_NUMBER = "ACTIVITY_TYPE_UPDATE_USER_PHONE_NUMBER"
    ACTIVITY_TYPE_INIT_FIAT_ON_RAMP = "ACTIVITY_TYPE_INIT_FIAT_ON_RAMP"
    ACTIVITY_TYPE_CREATE_SMART_CONTRACT_INTERFACE = (
        "ACTIVITY_TYPE_CREATE_SMART_CONTRACT_INTERFACE"
    )
    ACTIVITY_TYPE_DELETE_SMART_CONTRACT_INTERFACE = (
        "ACTIVITY_TYPE_DELETE_SMART_CONTRACT_INTERFACE"
    )
    ACTIVITY_TYPE_ENABLE_AUTH_PROXY = "ACTIVITY_TYPE_ENABLE_AUTH_PROXY"
    ACTIVITY_TYPE_DISABLE_AUTH_PROXY = "ACTIVITY_TYPE_DISABLE_AUTH_PROXY"
    ACTIVITY_TYPE_UPDATE_AUTH_PROXY_CONFIG = "ACTIVITY_TYPE_UPDATE_AUTH_PROXY_CONFIG"
    ACTIVITY_TYPE_CREATE_OAUTH2_CREDENTIAL = "ACTIVITY_TYPE_CREATE_OAUTH2_CREDENTIAL"
    ACTIVITY_TYPE_UPDATE_OAUTH2_CREDENTIAL = "ACTIVITY_TYPE_UPDATE_OAUTH2_CREDENTIAL"
    ACTIVITY_TYPE_DELETE_OAUTH2_CREDENTIAL = "ACTIVITY_TYPE_DELETE_OAUTH2_CREDENTIAL"
    ACTIVITY_TYPE_OAUTH2_AUTHENTICATE = "ACTIVITY_TYPE_OAUTH2_AUTHENTICATE"
    ACTIVITY_TYPE_DELETE_WALLET_ACCOUNTS = "ACTIVITY_TYPE_DELETE_WALLET_ACCOUNTS"
    ACTIVITY_TYPE_DELETE_POLICIES = "ACTIVITY_TYPE_DELETE_POLICIES"
    ACTIVITY_TYPE_ETH_SEND_RAW_TRANSACTION = "ACTIVITY_TYPE_ETH_SEND_RAW_TRANSACTION"
    ACTIVITY_TYPE_ETH_SEND_TRANSACTION = "ACTIVITY_TYPE_ETH_SEND_TRANSACTION"
    ACTIVITY_TYPE_CREATE_FIAT_ON_RAMP_CREDENTIAL = (
        "ACTIVITY_TYPE_CREATE_FIAT_ON_RAMP_CREDENTIAL"
    )
    ACTIVITY_TYPE_UPDATE_FIAT_ON_RAMP_CREDENTIAL = (
        "ACTIVITY_TYPE_UPDATE_FIAT_ON_RAMP_CREDENTIAL"
    )
    ACTIVITY_TYPE_DELETE_FIAT_ON_RAMP_CREDENTIAL = (
        "ACTIVITY_TYPE_DELETE_FIAT_ON_RAMP_CREDENTIAL"
    )
    ACTIVITY_TYPE_EMAIL_AUTH_V3 = "ACTIVITY_TYPE_EMAIL_AUTH_V3"
    ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY_V2 = (
        "ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY_V2"
    )
    ACTIVITY_TYPE_INIT_OTP_AUTH_V3 = "ACTIVITY_TYPE_INIT_OTP_AUTH_V3"
    ACTIVITY_TYPE_INIT_OTP_V2 = "ACTIVITY_TYPE_INIT_OTP_V2"
    ACTIVITY_TYPE_UPSERT_GAS_USAGE_CONFIG = "ACTIVITY_TYPE_UPSERT_GAS_USAGE_CONFIG"


class v1AddressFormat(str, Enum):
    ADDRESS_FORMAT_UNCOMPRESSED = "ADDRESS_FORMAT_UNCOMPRESSED"
    ADDRESS_FORMAT_COMPRESSED = "ADDRESS_FORMAT_COMPRESSED"
    ADDRESS_FORMAT_ETHEREUM = "ADDRESS_FORMAT_ETHEREUM"
    ADDRESS_FORMAT_SOLANA = "ADDRESS_FORMAT_SOLANA"
    ADDRESS_FORMAT_COSMOS = "ADDRESS_FORMAT_COSMOS"
    ADDRESS_FORMAT_TRON = "ADDRESS_FORMAT_TRON"
    ADDRESS_FORMAT_SUI = "ADDRESS_FORMAT_SUI"
    ADDRESS_FORMAT_APTOS = "ADDRESS_FORMAT_APTOS"
    ADDRESS_FORMAT_BITCOIN_MAINNET_P2PKH = "ADDRESS_FORMAT_BITCOIN_MAINNET_P2PKH"
    ADDRESS_FORMAT_BITCOIN_MAINNET_P2SH = "ADDRESS_FORMAT_BITCOIN_MAINNET_P2SH"
    ADDRESS_FORMAT_BITCOIN_MAINNET_P2WPKH = "ADDRESS_FORMAT_BITCOIN_MAINNET_P2WPKH"
    ADDRESS_FORMAT_BITCOIN_MAINNET_P2WSH = "ADDRESS_FORMAT_BITCOIN_MAINNET_P2WSH"
    ADDRESS_FORMAT_BITCOIN_MAINNET_P2TR = "ADDRESS_FORMAT_BITCOIN_MAINNET_P2TR"
    ADDRESS_FORMAT_BITCOIN_TESTNET_P2PKH = "ADDRESS_FORMAT_BITCOIN_TESTNET_P2PKH"
    ADDRESS_FORMAT_BITCOIN_TESTNET_P2SH = "ADDRESS_FORMAT_BITCOIN_TESTNET_P2SH"
    ADDRESS_FORMAT_BITCOIN_TESTNET_P2WPKH = "ADDRESS_FORMAT_BITCOIN_TESTNET_P2WPKH"
    ADDRESS_FORMAT_BITCOIN_TESTNET_P2WSH = "ADDRESS_FORMAT_BITCOIN_TESTNET_P2WSH"
    ADDRESS_FORMAT_BITCOIN_TESTNET_P2TR = "ADDRESS_FORMAT_BITCOIN_TESTNET_P2TR"
    ADDRESS_FORMAT_BITCOIN_SIGNET_P2PKH = "ADDRESS_FORMAT_BITCOIN_SIGNET_P2PKH"
    ADDRESS_FORMAT_BITCOIN_SIGNET_P2SH = "ADDRESS_FORMAT_BITCOIN_SIGNET_P2SH"
    ADDRESS_FORMAT_BITCOIN_SIGNET_P2WPKH = "ADDRESS_FORMAT_BITCOIN_SIGNET_P2WPKH"
    ADDRESS_FORMAT_BITCOIN_SIGNET_P2WSH = "ADDRESS_FORMAT_BITCOIN_SIGNET_P2WSH"
    ADDRESS_FORMAT_BITCOIN_SIGNET_P2TR = "ADDRESS_FORMAT_BITCOIN_SIGNET_P2TR"
    ADDRESS_FORMAT_BITCOIN_REGTEST_P2PKH = "ADDRESS_FORMAT_BITCOIN_REGTEST_P2PKH"
    ADDRESS_FORMAT_BITCOIN_REGTEST_P2SH = "ADDRESS_FORMAT_BITCOIN_REGTEST_P2SH"
    ADDRESS_FORMAT_BITCOIN_REGTEST_P2WPKH = "ADDRESS_FORMAT_BITCOIN_REGTEST_P2WPKH"
    ADDRESS_FORMAT_BITCOIN_REGTEST_P2WSH = "ADDRESS_FORMAT_BITCOIN_REGTEST_P2WSH"
    ADDRESS_FORMAT_BITCOIN_REGTEST_P2TR = "ADDRESS_FORMAT_BITCOIN_REGTEST_P2TR"
    ADDRESS_FORMAT_SEI = "ADDRESS_FORMAT_SEI"
    ADDRESS_FORMAT_XLM = "ADDRESS_FORMAT_XLM"
    ADDRESS_FORMAT_DOGE_MAINNET = "ADDRESS_FORMAT_DOGE_MAINNET"
    ADDRESS_FORMAT_DOGE_TESTNET = "ADDRESS_FORMAT_DOGE_TESTNET"
    ADDRESS_FORMAT_TON_V3R2 = "ADDRESS_FORMAT_TON_V3R2"
    ADDRESS_FORMAT_TON_V4R2 = "ADDRESS_FORMAT_TON_V4R2"
    ADDRESS_FORMAT_TON_V5R1 = "ADDRESS_FORMAT_TON_V5R1"
    ADDRESS_FORMAT_XRP = "ADDRESS_FORMAT_XRP"


class v1ApiKey(TurnkeyBaseModel):
    credential: externaldatav1Credential = Field(
        description="A User credential that can be used to authenticate to Turnkey."
    )
    apiKeyId: str = Field(description="Unique identifier for a given API Key.")
    apiKeyName: str = Field(description="Human-readable name for an API Key.")
    createdAt: externaldatav1Timestamp
    updatedAt: externaldatav1Timestamp
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Optional window (in seconds) indicating how long the API Key should last.",
    )


class v1ApiKeyCurve(str, Enum):
    API_KEY_CURVE_P256 = "API_KEY_CURVE_P256"
    API_KEY_CURVE_SECP256K1 = "API_KEY_CURVE_SECP256K1"
    API_KEY_CURVE_ED25519 = "API_KEY_CURVE_ED25519"


class v1ApiKeyParamsV2(TurnkeyBaseModel):
    apiKeyName: str = Field(description="Human-readable name for an API Key.")
    publicKey: str = Field(
        description="The public component of a cryptographic key pair used to sign messages and transactions."
    )
    curveType: v1ApiKeyCurve = Field(
        description="The curve type to be used for processing API key signatures."
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Optional window (in seconds) indicating how long the API Key should last.",
    )


class v1ApiOnlyUserParams(TurnkeyBaseModel):
    userName: str = Field(description="The name of the new API-only User.")
    userEmail: Optional[str] = Field(
        default=None, description="The email address for this API-only User (optional)."
    )
    userTags: List[str] = Field(
        description="A list of tags assigned to the new API-only User. This field, if not needed, should be an empty array in your request body."
    )
    apiKeys: List[apiApiKeyParams] = Field(
        description="A list of API Key parameters. This field, if not needed, should be an empty array in your request body."
    )


class v1AppProof(TurnkeyBaseModel):
    scheme: externaldatav1SignatureScheme = Field(description="Scheme of signing key.")
    publicKey: str = Field(description="Ephemeral public key.")
    proofPayload: str = Field(description="JSON serialized AppProofPayload.")
    signature: str = Field(description="Signature over hashed proof_payload.")


class v1ApproveActivityIntent(TurnkeyBaseModel):
    fingerprint: str = Field(description="An artifact verifying a User's action.")


class v1ApproveActivityRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1ApproveActivityIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1Attestation(TurnkeyBaseModel):
    credentialId: str = Field(
        description="The cbor encoded then base64 url encoded id of the credential."
    )
    clientDataJson: str = Field(
        description="A base64 url encoded payload containing metadata about the signing context and the challenge."
    )
    attestationObject: str = Field(
        description="A base64 url encoded payload containing authenticator data and any attestation the webauthn provider chooses."
    )
    transports: List[v1AuthenticatorTransport] = Field(
        description="The type of authenticator transports."
    )


class v1Authenticator(TurnkeyBaseModel):
    transports: List[v1AuthenticatorTransport] = Field(
        description="Types of transports that may be used by an Authenticator (e.g., USB, NFC, BLE)."
    )
    attestationType: str
    aaguid: str = Field(
        description="Identifier indicating the type of the Security Key."
    )
    credentialId: str = Field(
        description="Unique identifier for a WebAuthn credential."
    )
    model: str = Field(description="The type of Authenticator device.")
    credential: externaldatav1Credential = Field(
        description="A User credential that can be used to authenticate to Turnkey."
    )
    authenticatorId: str = Field(
        description="Unique identifier for a given Authenticator."
    )
    authenticatorName: str = Field(
        description="Human-readable name for an Authenticator."
    )
    createdAt: externaldatav1Timestamp
    updatedAt: externaldatav1Timestamp


class v1AuthenticatorAttestationResponse(TurnkeyBaseModel):
    clientDataJson: str
    attestationObject: str
    transports: Optional[List[v1AuthenticatorTransport]] = Field(default=None)
    authenticatorAttachment: Optional[str] = Field(default=None)


class v1AuthenticatorParams(TurnkeyBaseModel):
    authenticatorName: str = Field(
        description="Human-readable name for an Authenticator."
    )
    userId: str = Field(description="Unique identifier for a given User.")
    attestation: v1PublicKeyCredentialWithAttestation
    challenge: str = Field(
        description="Challenge presented for authentication purposes."
    )


class v1AuthenticatorParamsV2(TurnkeyBaseModel):
    authenticatorName: str = Field(
        description="Human-readable name for an Authenticator."
    )
    challenge: str = Field(
        description="Challenge presented for authentication purposes."
    )
    attestation: v1Attestation = Field(
        description="The attestation that proves custody of the authenticator and provides metadata about it."
    )


class v1AuthenticatorTransport(str, Enum):
    AUTHENTICATOR_TRANSPORT_BLE = "AUTHENTICATOR_TRANSPORT_BLE"
    AUTHENTICATOR_TRANSPORT_INTERNAL = "AUTHENTICATOR_TRANSPORT_INTERNAL"
    AUTHENTICATOR_TRANSPORT_NFC = "AUTHENTICATOR_TRANSPORT_NFC"
    AUTHENTICATOR_TRANSPORT_USB = "AUTHENTICATOR_TRANSPORT_USB"
    AUTHENTICATOR_TRANSPORT_HYBRID = "AUTHENTICATOR_TRANSPORT_HYBRID"


class v1BootProof(TurnkeyBaseModel):
    ephemeralPublicKeyHex: str = Field(
        description="The hex encoded Ephemeral Public Key."
    )
    awsAttestationDocB64: str = Field(
        description="The DER encoded COSE Sign1 struct Attestation doc."
    )
    qosManifestB64: str = Field(
        description="The borsch serialized base64 encoded Manifest."
    )
    qosManifestEnvelopeB64: str = Field(
        description="The borsch serialized base64 encoded Manifest Envelope."
    )
    deploymentLabel: str = Field(
        description="The label under which the enclave app was deployed."
    )
    enclaveApp: str = Field(description="Name of the enclave app")
    owner: str = Field(description="Owner of the app i.e. 'tkhq'")
    createdAt: externaldatav1Timestamp


class v1BootProofResponse(TurnkeyBaseModel):
    bootProof: v1BootProof


class v1ClientSignature(TurnkeyBaseModel):
    publicKey: str = Field(
        description="The public component of a cryptographic key pair used to create the signature."
    )
    scheme: v1ClientSignatureScheme = Field(
        description="The signature scheme used to generate the client signature."
    )
    message: str = Field(description="The message that was signed.")
    signature: str = Field(description="The cryptographic signature over the message.")


class v1ClientSignatureScheme(str, Enum):
    CLIENT_SIGNATURE_SCHEME_API_P256 = "CLIENT_SIGNATURE_SCHEME_API_P256"


class v1Config(TurnkeyBaseModel):
    features: Optional[List[v1Feature]] = Field(default=None)
    quorum: Optional[externaldatav1Quorum] = Field(default=None)


class v1CreateApiKeysIntent(TurnkeyBaseModel):
    apiKeys: List[apiApiKeyParams] = Field(description="A list of API Keys.")
    userId: str = Field(description="Unique identifier for a given User.")


class v1CreateApiKeysIntentV2(TurnkeyBaseModel):
    apiKeys: List[v1ApiKeyParamsV2] = Field(description="A list of API Keys.")
    userId: str = Field(description="Unique identifier for a given User.")


class v1CreateApiKeysRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1CreateApiKeysIntentV2
    generateAppProofs: Optional[bool] = Field(default=None)


class v1CreateApiKeysResult(TurnkeyBaseModel):
    apiKeyIds: List[str] = Field(description="A list of API Key IDs.")


class v1CreateApiOnlyUsersIntent(TurnkeyBaseModel):
    apiOnlyUsers: List[v1ApiOnlyUserParams] = Field(
        description="A list of API-only Users to create."
    )


class v1CreateApiOnlyUsersRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1CreateApiOnlyUsersIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1CreateApiOnlyUsersResult(TurnkeyBaseModel):
    userIds: List[str] = Field(description="A list of API-only User IDs.")


class v1CreateAuthenticatorsIntent(TurnkeyBaseModel):
    authenticators: List[v1AuthenticatorParams] = Field(
        description="A list of Authenticators."
    )
    userId: str = Field(description="Unique identifier for a given User.")


class v1CreateAuthenticatorsIntentV2(TurnkeyBaseModel):
    authenticators: List[v1AuthenticatorParamsV2] = Field(
        description="A list of Authenticators."
    )
    userId: str = Field(description="Unique identifier for a given User.")


class v1CreateAuthenticatorsRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1CreateAuthenticatorsIntentV2
    generateAppProofs: Optional[bool] = Field(default=None)


class v1CreateAuthenticatorsResult(TurnkeyBaseModel):
    authenticatorIds: List[str] = Field(description="A list of Authenticator IDs.")


class v1CreateFiatOnRampCredentialIntent(TurnkeyBaseModel):
    onrampProvider: v1FiatOnRampProvider = Field(
        description="The fiat on-ramp provider"
    )
    projectId: Optional[str] = Field(
        default=None,
        description="Project ID for the on-ramp provider. Some providers, like Coinbase, require this additional identifier",
    )
    publishableApiKey: str = Field(
        description="Publishable API key for the on-ramp provider"
    )
    encryptedSecretApiKey: str = Field(
        description="Secret API key for the on-ramp provider encrypted to our on-ramp encryption public key"
    )
    encryptedPrivateApiKey: Optional[str] = Field(
        default=None,
        description="Private API key for the on-ramp provider encrypted to our on-ramp encryption public key. Some providers, like Coinbase, require this additional key.",
    )
    sandboxMode: Optional[bool] = Field(
        default=None, description="If the on-ramp credential is a sandbox credential"
    )


class v1CreateFiatOnRampCredentialRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1CreateFiatOnRampCredentialIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1CreateFiatOnRampCredentialResult(TurnkeyBaseModel):
    fiatOnRampCredentialId: str = Field(
        description="Unique identifier of the Fiat On-Ramp credential that was created"
    )


class v1CreateInvitationsIntent(TurnkeyBaseModel):
    invitations: List[v1InvitationParams] = Field(description="A list of Invitations.")


class v1CreateInvitationsRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1CreateInvitationsIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1CreateInvitationsResult(TurnkeyBaseModel):
    invitationIds: List[str] = Field(description="A list of Invitation IDs")


class v1CreateOauth2CredentialIntent(TurnkeyBaseModel):
    provider: v1Oauth2Provider = Field(description="The OAuth 2.0 provider")
    clientId: str = Field(description="The Client ID issued by the OAuth 2.0 provider")
    encryptedClientSecret: str = Field(
        description="The client secret issued by the OAuth 2.0 provider encrypted to the TLS Fetcher quorum key"
    )


class v1CreateOauth2CredentialRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1CreateOauth2CredentialIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1CreateOauth2CredentialResult(TurnkeyBaseModel):
    oauth2CredentialId: str = Field(
        description="Unique identifier of the OAuth 2.0 credential that was created"
    )


class v1CreateOauthProvidersIntent(TurnkeyBaseModel):
    userId: str = Field(description="The ID of the User to add an Oauth provider to")
    oauthProviders: List[v1OauthProviderParams] = Field(
        description="A list of Oauth providers."
    )


class v1CreateOauthProvidersRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1CreateOauthProvidersIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1CreateOauthProvidersResult(TurnkeyBaseModel):
    providerIds: List[str] = Field(
        description="A list of unique identifiers for Oauth Providers"
    )


class v1CreateOrganizationIntent(TurnkeyBaseModel):
    organizationName: str = Field(
        description="Human-readable name for an Organization."
    )
    rootEmail: str = Field(description="The root user's email address.")
    rootAuthenticator: v1AuthenticatorParams = Field(
        description="The root user's Authenticator."
    )
    rootUserId: Optional[str] = Field(
        default=None, description="Unique identifier for the root user object."
    )


class v1CreateOrganizationIntentV2(TurnkeyBaseModel):
    organizationName: str = Field(
        description="Human-readable name for an Organization."
    )
    rootEmail: str = Field(description="The root user's email address.")
    rootAuthenticator: v1AuthenticatorParamsV2 = Field(
        description="The root user's Authenticator."
    )
    rootUserId: Optional[str] = Field(
        default=None, description="Unique identifier for the root user object."
    )


class v1CreateOrganizationResult(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )


class v1CreatePoliciesIntent(TurnkeyBaseModel):
    policies: List[v1CreatePolicyIntentV3] = Field(
        description="An array of policy intents to be created."
    )


class v1CreatePoliciesRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1CreatePoliciesIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1CreatePoliciesResult(TurnkeyBaseModel):
    policyIds: List[str] = Field(
        description="A list of unique identifiers for the created policies."
    )


class v1CreatePolicyIntent(TurnkeyBaseModel):
    policyName: str = Field(description="Human-readable name for a Policy.")
    selectors: List[v1Selector] = Field(
        description="A list of simple functions each including a subject, target and boolean. See Policy Engine Language section for additional details."
    )
    effect: v1Effect = Field(
        description="The instruction to DENY or ALLOW a particular activity following policy selector(s)."
    )
    notes: Optional[str] = Field(default=None)


class v1CreatePolicyIntentV2(TurnkeyBaseModel):
    policyName: str = Field(description="Human-readable name for a Policy.")
    selectors: List[v1SelectorV2] = Field(
        description="A list of simple functions each including a subject, target and boolean. See Policy Engine Language section for additional details."
    )
    effect: v1Effect = Field(
        description="Whether to ALLOW or DENY requests that match the condition and consensus requirements."
    )
    notes: Optional[str] = Field(default=None)


class v1CreatePolicyIntentV3(TurnkeyBaseModel):
    policyName: str = Field(description="Human-readable name for a Policy.")
    effect: v1Effect = Field(
        description="The instruction to DENY or ALLOW an activity."
    )
    condition: Optional[str] = Field(
        default=None, description="The condition expression that triggers the Effect"
    )
    consensus: Optional[str] = Field(
        default=None, description="The consensus expression that triggers the Effect"
    )
    notes: str = Field(description="Notes for a Policy.")


class v1CreatePolicyRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1CreatePolicyIntentV3
    generateAppProofs: Optional[bool] = Field(default=None)


class v1CreatePolicyResult(TurnkeyBaseModel):
    policyId: str = Field(description="Unique identifier for a given Policy.")


class v1CreatePrivateKeyTagIntent(TurnkeyBaseModel):
    privateKeyTagName: str = Field(
        description="Human-readable name for a Private Key Tag."
    )
    privateKeyIds: List[str] = Field(description="A list of Private Key IDs.")


class v1CreatePrivateKeyTagRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1CreatePrivateKeyTagIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1CreatePrivateKeyTagResult(TurnkeyBaseModel):
    privateKeyTagId: str = Field(
        description="Unique identifier for a given Private Key Tag."
    )
    privateKeyIds: List[str] = Field(description="A list of Private Key IDs.")


class v1CreatePrivateKeysIntent(TurnkeyBaseModel):
    privateKeys: List[v1PrivateKeyParams] = Field(description="A list of Private Keys.")


class v1CreatePrivateKeysIntentV2(TurnkeyBaseModel):
    privateKeys: List[v1PrivateKeyParams] = Field(description="A list of Private Keys.")


class v1CreatePrivateKeysRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1CreatePrivateKeysIntentV2
    generateAppProofs: Optional[bool] = Field(default=None)


class v1CreatePrivateKeysResult(TurnkeyBaseModel):
    privateKeyIds: List[str] = Field(description="A list of Private Key IDs.")


class v1CreatePrivateKeysResultV2(TurnkeyBaseModel):
    privateKeys: List[v1PrivateKeyResult] = Field(
        description="A list of Private Key IDs and addresses."
    )


class v1CreateReadOnlySessionIntent(TurnkeyBaseModel):
    pass


class v1CreateReadOnlySessionRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1CreateReadOnlySessionIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1CreateReadOnlySessionResult(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons."
    )
    organizationName: str = Field(
        description="Human-readable name for an Organization."
    )
    userId: str = Field(description="Unique identifier for a given User.")
    username: str = Field(description="Human-readable name for a User.")
    session: str = Field(description="String representing a read only session")
    sessionExpiry: str = Field(
        description="UTC timestamp in seconds representing the expiry time for the read only session."
    )


class v1CreateReadWriteSessionIntent(TurnkeyBaseModel):
    targetPublicKey: str = Field(
        description="Client-side public key generated by the user, to which the read write session bundle (credentials) will be encrypted."
    )
    email: str = Field(
        description="Email of the user to create a read write session for"
    )
    apiKeyName: Optional[str] = Field(
        default=None,
        description="Optional human-readable name for an API Key. If none provided, default to Read Write Session - <Timestamp>",
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.",
    )


class v1CreateReadWriteSessionIntentV2(TurnkeyBaseModel):
    targetPublicKey: str = Field(
        description="Client-side public key generated by the user, to which the read write session bundle (credentials) will be encrypted."
    )
    userId: Optional[str] = Field(
        default=None, description="Unique identifier for a given User."
    )
    apiKeyName: Optional[str] = Field(
        default=None,
        description="Optional human-readable name for an API Key. If none provided, default to Read Write Session - <Timestamp>",
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.",
    )
    invalidateExisting: Optional[bool] = Field(
        default=None,
        description="Invalidate all other previously generated ReadWriteSession API keys",
    )


class v1CreateReadWriteSessionRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1CreateReadWriteSessionIntentV2
    generateAppProofs: Optional[bool] = Field(default=None)


class v1CreateReadWriteSessionResult(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons."
    )
    organizationName: str = Field(
        description="Human-readable name for an Organization."
    )
    userId: str = Field(description="Unique identifier for a given User.")
    username: str = Field(description="Human-readable name for a User.")
    apiKeyId: str = Field(description="Unique identifier for the created API key.")
    credentialBundle: str = Field(description="HPKE encrypted credential bundle")


class v1CreateReadWriteSessionResultV2(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons."
    )
    organizationName: str = Field(
        description="Human-readable name for an Organization."
    )
    userId: str = Field(description="Unique identifier for a given User.")
    username: str = Field(description="Human-readable name for a User.")
    apiKeyId: str = Field(description="Unique identifier for the created API key.")
    credentialBundle: str = Field(description="HPKE encrypted credential bundle")


class v1CreateSmartContractInterfaceIntent(TurnkeyBaseModel):
    smartContractAddress: str = Field(
        description="Corresponding contract address or program ID"
    )
    smartContractInterface: str = Field(
        description="ABI/IDL as a JSON string. Limited to 400kb"
    )
    type: v1SmartContractInterfaceType
    label: str = Field(
        description="Human-readable name for a Smart Contract Interface."
    )
    notes: Optional[str] = Field(
        default=None, description="Notes for a Smart Contract Interface."
    )


class v1CreateSmartContractInterfaceRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1CreateSmartContractInterfaceIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1CreateSmartContractInterfaceResult(TurnkeyBaseModel):
    smartContractInterfaceId: str = Field(
        description="The ID of the created Smart Contract Interface."
    )


class v1CreateSubOrganizationIntent(TurnkeyBaseModel):
    name: str = Field(description="Name for this sub-organization")
    rootAuthenticator: v1AuthenticatorParamsV2 = Field(
        description="Root User authenticator for this new sub-organization"
    )


class v1CreateSubOrganizationIntentV2(TurnkeyBaseModel):
    subOrganizationName: str = Field(description="Name for this sub-organization")
    rootUsers: List[v1RootUserParams] = Field(
        description="Root users to create within this sub-organization"
    )
    rootQuorumThreshold: int = Field(
        description="The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users"
    )


class v1CreateSubOrganizationIntentV3(TurnkeyBaseModel):
    subOrganizationName: str = Field(description="Name for this sub-organization")
    rootUsers: List[v1RootUserParams] = Field(
        description="Root users to create within this sub-organization"
    )
    rootQuorumThreshold: int = Field(
        description="The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users"
    )
    privateKeys: List[v1PrivateKeyParams] = Field(description="A list of Private Keys.")


class v1CreateSubOrganizationIntentV4(TurnkeyBaseModel):
    subOrganizationName: str = Field(description="Name for this sub-organization")
    rootUsers: List[v1RootUserParams] = Field(
        description="Root users to create within this sub-organization"
    )
    rootQuorumThreshold: int = Field(
        description="The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users"
    )
    wallet: Optional[v1WalletParams] = Field(
        default=None, description="The wallet to create for the sub-organization"
    )
    disableEmailRecovery: Optional[bool] = Field(
        default=None, description="Disable email recovery for the sub-organization"
    )
    disableEmailAuth: Optional[bool] = Field(
        default=None, description="Disable email auth for the sub-organization"
    )


class v1CreateSubOrganizationIntentV5(TurnkeyBaseModel):
    subOrganizationName: str = Field(description="Name for this sub-organization")
    rootUsers: List[v1RootUserParamsV2] = Field(
        description="Root users to create within this sub-organization"
    )
    rootQuorumThreshold: int = Field(
        description="The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users"
    )
    wallet: Optional[v1WalletParams] = Field(
        default=None, description="The wallet to create for the sub-organization"
    )
    disableEmailRecovery: Optional[bool] = Field(
        default=None, description="Disable email recovery for the sub-organization"
    )
    disableEmailAuth: Optional[bool] = Field(
        default=None, description="Disable email auth for the sub-organization"
    )


class v1CreateSubOrganizationIntentV6(TurnkeyBaseModel):
    subOrganizationName: str = Field(description="Name for this sub-organization")
    rootUsers: List[v1RootUserParamsV3] = Field(
        description="Root users to create within this sub-organization"
    )
    rootQuorumThreshold: int = Field(
        description="The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users"
    )
    wallet: Optional[v1WalletParams] = Field(
        default=None, description="The wallet to create for the sub-organization"
    )
    disableEmailRecovery: Optional[bool] = Field(
        default=None, description="Disable email recovery for the sub-organization"
    )
    disableEmailAuth: Optional[bool] = Field(
        default=None, description="Disable email auth for the sub-organization"
    )


class v1CreateSubOrganizationIntentV7(TurnkeyBaseModel):
    subOrganizationName: str = Field(description="Name for this sub-organization")
    rootUsers: List[v1RootUserParamsV4] = Field(
        description="Root users to create within this sub-organization"
    )
    rootQuorumThreshold: int = Field(
        description="The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users"
    )
    wallet: Optional[v1WalletParams] = Field(
        default=None, description="The wallet to create for the sub-organization"
    )
    disableEmailRecovery: Optional[bool] = Field(
        default=None, description="Disable email recovery for the sub-organization"
    )
    disableEmailAuth: Optional[bool] = Field(
        default=None, description="Disable email auth for the sub-organization"
    )
    disableSmsAuth: Optional[bool] = Field(
        default=None, description="Disable OTP SMS auth for the sub-organization"
    )
    disableOtpEmailAuth: Optional[bool] = Field(
        default=None, description="Disable OTP email auth for the sub-organization"
    )
    verificationToken: Optional[str] = Field(
        default=None,
        description="Signed JWT containing a unique id, expiry, verification type, contact",
    )
    clientSignature: Optional[v1ClientSignature] = Field(
        default=None,
        description="Optional signature proving authorization for this sub-organization creation. The signature is over the verification token ID and the root user parameters for the root user associated with the verification token. Only required if a public key was provided during the verification step.",
    )


class v1CreateSubOrganizationRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1CreateSubOrganizationIntentV7
    generateAppProofs: Optional[bool] = Field(default=None)


class v1CreateSubOrganizationResult(TurnkeyBaseModel):
    subOrganizationId: str
    rootUserIds: Optional[List[str]] = Field(default=None)


class v1CreateSubOrganizationResultV3(TurnkeyBaseModel):
    subOrganizationId: str
    privateKeys: List[v1PrivateKeyResult] = Field(
        description="A list of Private Key IDs and addresses."
    )
    rootUserIds: Optional[List[str]] = Field(default=None)


class v1CreateSubOrganizationResultV4(TurnkeyBaseModel):
    subOrganizationId: str
    wallet: Optional[v1WalletResult] = Field(default=None)
    rootUserIds: Optional[List[str]] = Field(default=None)


class v1CreateSubOrganizationResultV5(TurnkeyBaseModel):
    subOrganizationId: str
    wallet: Optional[v1WalletResult] = Field(default=None)
    rootUserIds: Optional[List[str]] = Field(default=None)


class v1CreateSubOrganizationResultV6(TurnkeyBaseModel):
    subOrganizationId: str
    wallet: Optional[v1WalletResult] = Field(default=None)
    rootUserIds: Optional[List[str]] = Field(default=None)


class v1CreateSubOrganizationResultV7(TurnkeyBaseModel):
    subOrganizationId: str
    wallet: Optional[v1WalletResult] = Field(default=None)
    rootUserIds: Optional[List[str]] = Field(default=None)


class v1CreateUserTagIntent(TurnkeyBaseModel):
    userTagName: str = Field(description="Human-readable name for a User Tag.")
    userIds: List[str] = Field(description="A list of User IDs.")


class v1CreateUserTagRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1CreateUserTagIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1CreateUserTagResult(TurnkeyBaseModel):
    userTagId: str = Field(description="Unique identifier for a given User Tag.")
    userIds: List[str] = Field(description="A list of User IDs.")


class v1CreateUsersIntent(TurnkeyBaseModel):
    users: List[v1UserParams] = Field(description="A list of Users.")


class v1CreateUsersIntentV2(TurnkeyBaseModel):
    users: List[v1UserParamsV2] = Field(description="A list of Users.")


class v1CreateUsersIntentV3(TurnkeyBaseModel):
    users: List[v1UserParamsV3] = Field(description="A list of Users.")


class v1CreateUsersRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1CreateUsersIntentV3
    generateAppProofs: Optional[bool] = Field(default=None)


class v1CreateUsersResult(TurnkeyBaseModel):
    userIds: List[str] = Field(description="A list of User IDs.")


class v1CreateWalletAccountsIntent(TurnkeyBaseModel):
    walletId: str = Field(description="Unique identifier for a given Wallet.")
    accounts: List[v1WalletAccountParams] = Field(
        description="A list of wallet Accounts."
    )
    persist: Optional[bool] = Field(
        default=None,
        description="Indicates if the wallet accounts should be persisted. This is helpful if you'd like to see the addresses of different derivation paths without actually creating the accounts. Defaults to true.",
    )


class v1CreateWalletAccountsRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1CreateWalletAccountsIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1CreateWalletAccountsResult(TurnkeyBaseModel):
    addresses: List[str] = Field(description="A list of derived addresses.")


class v1CreateWalletIntent(TurnkeyBaseModel):
    walletName: str = Field(description="Human-readable name for a Wallet.")
    accounts: List[v1WalletAccountParams] = Field(
        description="A list of wallet Accounts. This field, if not needed, should be an empty array in your request body."
    )
    mnemonicLength: Optional[int] = Field(
        default=None,
        description="Length of mnemonic to generate the Wallet seed. Defaults to 12. Accepted values: 12, 15, 18, 21, 24.",
    )


class v1CreateWalletRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1CreateWalletIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1CreateWalletResult(TurnkeyBaseModel):
    walletId: str = Field(description="Unique identifier for a Wallet.")
    addresses: List[str] = Field(description="A list of account addresses.")


class v1CredPropsAuthenticationExtensionsClientOutputs(TurnkeyBaseModel):
    rk: bool


class v1CredentialType(str, Enum):
    CREDENTIAL_TYPE_WEBAUTHN_AUTHENTICATOR = "CREDENTIAL_TYPE_WEBAUTHN_AUTHENTICATOR"
    CREDENTIAL_TYPE_API_KEY_P256 = "CREDENTIAL_TYPE_API_KEY_P256"
    CREDENTIAL_TYPE_RECOVER_USER_KEY_P256 = "CREDENTIAL_TYPE_RECOVER_USER_KEY_P256"
    CREDENTIAL_TYPE_API_KEY_SECP256K1 = "CREDENTIAL_TYPE_API_KEY_SECP256K1"
    CREDENTIAL_TYPE_EMAIL_AUTH_KEY_P256 = "CREDENTIAL_TYPE_EMAIL_AUTH_KEY_P256"
    CREDENTIAL_TYPE_API_KEY_ED25519 = "CREDENTIAL_TYPE_API_KEY_ED25519"
    CREDENTIAL_TYPE_OTP_AUTH_KEY_P256 = "CREDENTIAL_TYPE_OTP_AUTH_KEY_P256"
    CREDENTIAL_TYPE_READ_WRITE_SESSION_KEY_P256 = (
        "CREDENTIAL_TYPE_READ_WRITE_SESSION_KEY_P256"
    )
    CREDENTIAL_TYPE_OAUTH_KEY_P256 = "CREDENTIAL_TYPE_OAUTH_KEY_P256"
    CREDENTIAL_TYPE_LOGIN = "CREDENTIAL_TYPE_LOGIN"


class v1Curve(str, Enum):
    CURVE_SECP256K1 = "CURVE_SECP256K1"
    CURVE_ED25519 = "CURVE_ED25519"


class v1DeleteApiKeysIntent(TurnkeyBaseModel):
    userId: str = Field(description="Unique identifier for a given User.")
    apiKeyIds: List[str] = Field(description="A list of API Key IDs.")


class v1DeleteApiKeysRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1DeleteApiKeysIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1DeleteApiKeysResult(TurnkeyBaseModel):
    apiKeyIds: List[str] = Field(description="A list of API Key IDs.")


class v1DeleteAuthenticatorsIntent(TurnkeyBaseModel):
    userId: str = Field(description="Unique identifier for a given User.")
    authenticatorIds: List[str] = Field(description="A list of Authenticator IDs.")


class v1DeleteAuthenticatorsRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1DeleteAuthenticatorsIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1DeleteAuthenticatorsResult(TurnkeyBaseModel):
    authenticatorIds: List[str] = Field(
        description="Unique identifier for a given Authenticator."
    )


class v1DeleteFiatOnRampCredentialIntent(TurnkeyBaseModel):
    fiatOnrampCredentialId: str = Field(
        description="The ID of the fiat on-ramp credential to delete"
    )


class v1DeleteFiatOnRampCredentialRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1DeleteFiatOnRampCredentialIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1DeleteFiatOnRampCredentialResult(TurnkeyBaseModel):
    fiatOnRampCredentialId: str = Field(
        description="Unique identifier of the Fiat On-Ramp credential that was deleted"
    )


class v1DeleteInvitationIntent(TurnkeyBaseModel):
    invitationId: str = Field(
        description="Unique identifier for a given Invitation object."
    )


class v1DeleteInvitationRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1DeleteInvitationIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1DeleteInvitationResult(TurnkeyBaseModel):
    invitationId: str = Field(description="Unique identifier for a given Invitation.")


class v1DeleteOauth2CredentialIntent(TurnkeyBaseModel):
    oauth2CredentialId: str = Field(
        description="The ID of the OAuth 2.0 credential to delete"
    )


class v1DeleteOauth2CredentialRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1DeleteOauth2CredentialIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1DeleteOauth2CredentialResult(TurnkeyBaseModel):
    oauth2CredentialId: str = Field(
        description="Unique identifier of the OAuth 2.0 credential that was deleted"
    )


class v1DeleteOauthProvidersIntent(TurnkeyBaseModel):
    userId: str = Field(
        description="The ID of the User to remove an Oauth provider from"
    )
    providerIds: List[str] = Field(
        description="Unique identifier for a given Provider."
    )


class v1DeleteOauthProvidersRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1DeleteOauthProvidersIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1DeleteOauthProvidersResult(TurnkeyBaseModel):
    providerIds: List[str] = Field(
        description="A list of unique identifiers for Oauth Providers"
    )


class v1DeleteOrganizationIntent(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )


class v1DeleteOrganizationResult(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )


class v1DeletePoliciesIntent(TurnkeyBaseModel):
    policyIds: List[str] = Field(
        description="List of unique identifiers for policies within an organization"
    )


class v1DeletePoliciesRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1DeletePoliciesIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1DeletePoliciesResult(TurnkeyBaseModel):
    policyIds: List[str] = Field(
        description="A list of unique identifiers for the deleted policies."
    )


class v1DeletePolicyIntent(TurnkeyBaseModel):
    policyId: str = Field(description="Unique identifier for a given Policy.")


class v1DeletePolicyRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1DeletePolicyIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1DeletePolicyResult(TurnkeyBaseModel):
    policyId: str = Field(description="Unique identifier for a given Policy.")


class v1DeletePrivateKeyTagsIntent(TurnkeyBaseModel):
    privateKeyTagIds: List[str] = Field(description="A list of Private Key Tag IDs.")


class v1DeletePrivateKeyTagsRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1DeletePrivateKeyTagsIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1DeletePrivateKeyTagsResult(TurnkeyBaseModel):
    privateKeyTagIds: List[str] = Field(description="A list of Private Key Tag IDs.")
    privateKeyIds: List[str] = Field(description="A list of Private Key IDs.")


class v1DeletePrivateKeysIntent(TurnkeyBaseModel):
    privateKeyIds: List[str] = Field(
        description="List of unique identifiers for private keys within an organization"
    )
    deleteWithoutExport: Optional[bool] = Field(
        default=None,
        description="Optional parameter for deleting the private keys, even if any have not been previously exported. If they have been exported, this field is ignored.",
    )


class v1DeletePrivateKeysRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1DeletePrivateKeysIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1DeletePrivateKeysResult(TurnkeyBaseModel):
    privateKeyIds: List[str] = Field(
        description="A list of private key unique identifiers that were removed"
    )


class v1DeleteSmartContractInterfaceIntent(TurnkeyBaseModel):
    smartContractInterfaceId: str = Field(
        description="The ID of a Smart Contract Interface intended for deletion."
    )


class v1DeleteSmartContractInterfaceRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1DeleteSmartContractInterfaceIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1DeleteSmartContractInterfaceResult(TurnkeyBaseModel):
    smartContractInterfaceId: str = Field(
        description="The ID of the deleted Smart Contract Interface."
    )


class v1DeleteSubOrganizationIntent(TurnkeyBaseModel):
    deleteWithoutExport: Optional[bool] = Field(
        default=None,
        description="Sub-organization deletion, by default, requires associated wallets and private keys to be exported for security reasons. Set this boolean to true to force sub-organization deletion even if some wallets or private keys within it have not been exported yet. Default: false.",
    )


class v1DeleteSubOrganizationRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1DeleteSubOrganizationIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1DeleteSubOrganizationResult(TurnkeyBaseModel):
    subOrganizationUuid: str = Field(
        description="Unique identifier of the sub organization that was removed"
    )


class v1DeleteUserTagsIntent(TurnkeyBaseModel):
    userTagIds: List[str] = Field(description="A list of User Tag IDs.")


class v1DeleteUserTagsRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1DeleteUserTagsIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1DeleteUserTagsResult(TurnkeyBaseModel):
    userTagIds: List[str] = Field(description="A list of User Tag IDs.")
    userIds: List[str] = Field(description="A list of User IDs.")


class v1DeleteUsersIntent(TurnkeyBaseModel):
    userIds: List[str] = Field(description="A list of User IDs.")


class v1DeleteUsersRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1DeleteUsersIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1DeleteUsersResult(TurnkeyBaseModel):
    userIds: List[str] = Field(description="A list of User IDs.")


class v1DeleteWalletAccountsIntent(TurnkeyBaseModel):
    walletAccountIds: List[str] = Field(
        description="List of unique identifiers for wallet accounts within an organization"
    )
    deleteWithoutExport: Optional[bool] = Field(
        default=None,
        description="Optional parameter for deleting the wallet accounts, even if any have not been previously exported. If they have been exported, this field is ignored.",
    )


class v1DeleteWalletAccountsRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1DeleteWalletAccountsIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1DeleteWalletAccountsResult(TurnkeyBaseModel):
    walletAccountIds: List[str] = Field(
        description="A list of wallet account unique identifiers that were removed"
    )


class v1DeleteWalletsIntent(TurnkeyBaseModel):
    walletIds: List[str] = Field(
        description="List of unique identifiers for wallets within an organization"
    )
    deleteWithoutExport: Optional[bool] = Field(
        default=None,
        description="Optional parameter for deleting the wallets, even if any have not been previously exported. If they have been exported, this field is ignored.",
    )


class v1DeleteWalletsRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1DeleteWalletsIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1DeleteWalletsResult(TurnkeyBaseModel):
    walletIds: List[str] = Field(
        description="A list of wallet unique identifiers that were removed"
    )


class v1DisableAuthProxyIntent(TurnkeyBaseModel):
    pass


class v1DisableAuthProxyResult(TurnkeyBaseModel):
    pass


class v1DisablePrivateKeyIntent(TurnkeyBaseModel):
    privateKeyId: str = Field(description="Unique identifier for a given Private Key.")


class v1DisablePrivateKeyResult(TurnkeyBaseModel):
    privateKeyId: str = Field(description="Unique identifier for a given Private Key.")


class v1Effect(str, Enum):
    EFFECT_ALLOW = "EFFECT_ALLOW"
    EFFECT_DENY = "EFFECT_DENY"


class v1EmailAuthCustomizationParams(TurnkeyBaseModel):
    appName: str = Field(
        description="The name of the application. This field is required and will be used in email notifications if an email template is not provided."
    )
    logoUrl: Optional[str] = Field(
        default=None,
        description="A URL pointing to a logo in PNG format. Note this logo will be resized to fit into 340px x 124px.",
    )
    magicLinkTemplate: Optional[str] = Field(
        default=None,
        description="A template for the URL to be used in a magic link button, e.g. `https://dapp.xyz/%s`. The auth bundle will be interpolated into the `%s`.",
    )
    templateVariables: Optional[str] = Field(
        default=None,
        description="JSON object containing key/value pairs to be used with custom templates.",
    )
    templateId: Optional[str] = Field(
        default=None,
        description="Unique identifier for a given Email Template. If not specified, the default is the most recent Email Template.",
    )


class v1EmailAuthIntent(TurnkeyBaseModel):
    email: str = Field(description="Email of the authenticating user.")
    targetPublicKey: str = Field(
        description="Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted."
    )
    apiKeyName: Optional[str] = Field(
        default=None,
        description="Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp>",
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.",
    )
    emailCustomization: Optional[v1EmailCustomizationParams] = Field(
        default=None,
        description="Optional parameters for customizing emails. If not provided, the default email will be used.",
    )
    invalidateExisting: Optional[bool] = Field(
        default=None,
        description="Invalidate all other previously generated Email Auth API keys",
    )
    sendFromEmailAddress: Optional[str] = Field(
        default=None,
        description="Optional custom email address from which to send the email",
    )
    sendFromEmailSenderName: Optional[str] = Field(
        default=None,
        description="Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'",
    )
    replyToEmailAddress: Optional[str] = Field(
        default=None, description="Optional custom email address to use as reply-to"
    )


class v1EmailAuthIntentV2(TurnkeyBaseModel):
    email: str = Field(description="Email of the authenticating user.")
    targetPublicKey: str = Field(
        description="Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted."
    )
    apiKeyName: Optional[str] = Field(
        default=None,
        description="Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp>",
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.",
    )
    emailCustomization: Optional[v1EmailCustomizationParams] = Field(
        default=None,
        description="Optional parameters for customizing emails. If not provided, the default email will be used.",
    )
    invalidateExisting: Optional[bool] = Field(
        default=None,
        description="Invalidate all other previously generated Email Auth API keys",
    )
    sendFromEmailAddress: Optional[str] = Field(
        default=None,
        description="Optional custom email address from which to send the email",
    )
    sendFromEmailSenderName: Optional[str] = Field(
        default=None,
        description="Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'",
    )
    replyToEmailAddress: Optional[str] = Field(
        default=None, description="Optional custom email address to use as reply-to"
    )


class v1EmailAuthIntentV3(TurnkeyBaseModel):
    email: str = Field(description="Email of the authenticating user.")
    targetPublicKey: str = Field(
        description="Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted."
    )
    apiKeyName: Optional[str] = Field(
        default=None,
        description="Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp>",
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.",
    )
    emailCustomization: v1EmailAuthCustomizationParams = Field(
        description="Parameters for customizing emails. If not provided, the default email will be used. Note that app_name is required."
    )
    invalidateExisting: Optional[bool] = Field(
        default=None,
        description="Invalidate all other previously generated Email Auth API keys",
    )
    sendFromEmailAddress: Optional[str] = Field(
        default=None,
        description="Optional custom email address from which to send the email",
    )
    sendFromEmailSenderName: Optional[str] = Field(
        default=None,
        description="Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'",
    )
    replyToEmailAddress: Optional[str] = Field(
        default=None, description="Optional custom email address to use as reply-to"
    )


class v1EmailAuthRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1EmailAuthIntentV3
    generateAppProofs: Optional[bool] = Field(default=None)


class v1EmailAuthResult(TurnkeyBaseModel):
    userId: str = Field(description="Unique identifier for the authenticating User.")
    apiKeyId: str = Field(description="Unique identifier for the created API key.")


class v1EmailCustomizationParams(TurnkeyBaseModel):
    appName: Optional[str] = Field(
        default=None, description="The name of the application."
    )
    logoUrl: Optional[str] = Field(
        default=None,
        description="A URL pointing to a logo in PNG format. Note this logo will be resized to fit into 340px x 124px.",
    )
    magicLinkTemplate: Optional[str] = Field(
        default=None,
        description="A template for the URL to be used in a magic link button, e.g. `https://dapp.xyz/%s`. The auth bundle will be interpolated into the `%s`.",
    )
    templateVariables: Optional[str] = Field(
        default=None,
        description="JSON object containing key/value pairs to be used with custom templates.",
    )
    templateId: Optional[str] = Field(
        default=None,
        description="Unique identifier for a given Email Template. If not specified, the default is the most recent Email Template.",
    )


class v1EmailCustomizationParamsV2(TurnkeyBaseModel):
    logoUrl: Optional[str] = Field(
        default=None,
        description="A URL pointing to a logo in PNG format. Note this logo will be resized to fit into 340px x 124px.",
    )
    magicLinkTemplate: Optional[str] = Field(
        default=None,
        description="A template for the URL to be used in a magic link button, e.g. `https://dapp.xyz/%s`. The auth bundle will be interpolated into the `%s`.",
    )
    templateVariables: Optional[str] = Field(
        default=None,
        description="JSON object containing key/value pairs to be used with custom templates.",
    )
    templateId: Optional[str] = Field(
        default=None,
        description="Unique identifier for a given Email Template. If not specified, the default is the most recent Email Template.",
    )


class v1EnableAuthProxyIntent(TurnkeyBaseModel):
    pass


class v1EnableAuthProxyResult(TurnkeyBaseModel):
    userId: str = Field(
        description="A User ID with permission to initiate authentication."
    )


class v1EthSendRawTransactionIntent(TurnkeyBaseModel):
    signedTransaction: str = Field(
        description="The raw, signed transaction to be sent."
    )
    caip2: str = Field(
        description="CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet)."
    )


class v1EthSendRawTransactionRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1EthSendRawTransactionIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1EthSendRawTransactionResult(TurnkeyBaseModel):
    transactionHash: str = Field(
        description="The transaction hash of the sent transaction"
    )


class v1EthSendTransactionIntent(TurnkeyBaseModel):
    from_: str = Field(
        alias="from",
        description="A wallet or private key address to sign with. This does not support private key IDs.",
    )
    sponsor: Optional[bool] = Field(
        default=None, description="Whether to sponsor this transaction via Gas Station."
    )
    caip2: str = Field(
        description="CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet)."
    )
    to: str = Field(description="Recipient address as a hex string with 0x prefix.")
    value: Optional[str] = Field(
        default=None, description="Amount of native asset to send in wei."
    )
    data: Optional[str] = Field(
        default=None, description="Hex-encoded call data for contract interactions."
    )
    nonce: Optional[str] = Field(
        default=None,
        description="Transaction nonce, for EIP-1559 and Turnkey Gas Station authorizations.",
    )
    gasLimit: Optional[str] = Field(
        default=None,
        description="Maximum amount of gas to use for this transaction, for EIP-1559 transactions.",
    )
    maxFeePerGas: Optional[str] = Field(
        default=None,
        description="Maximum total fee per gas unit (base fee + priority fee) in wei. Required for non-sponsored (EIP-1559) transactions. Not used for sponsored transactions.",
    )
    maxPriorityFeePerGas: Optional[str] = Field(
        default=None,
        description="Maximum priority fee (tip) per gas unit in wei. Required for non-sponsored (EIP-1559) transactions. Not used for sponsored transactions.",
    )
    gasStationNonce: Optional[str] = Field(
        default=None,
        description="The gas station delegate contract nonce. Only used when sponsor=true. Include this if you want maximal security posture.",
    )


class v1EthSendTransactionRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1EthSendTransactionIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1EthSendTransactionResult(TurnkeyBaseModel):
    sendTransactionStatusId: str = Field(
        description="The send_transaction_status ID associated with the transaction submission for sponsored transactions"
    )


class v1EthSendTransactionStatus(TurnkeyBaseModel):
    txHash: Optional[str] = Field(
        default=None, description="The Ethereum transaction hash, if available."
    )


class v1ExportPrivateKeyIntent(TurnkeyBaseModel):
    privateKeyId: str = Field(description="Unique identifier for a given Private Key.")
    targetPublicKey: str = Field(
        description="Client-side public key generated by the user, to which the export bundle will be encrypted."
    )


class v1ExportPrivateKeyRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1ExportPrivateKeyIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1ExportPrivateKeyResult(TurnkeyBaseModel):
    privateKeyId: str = Field(description="Unique identifier for a given Private Key.")
    exportBundle: str = Field(
        description="Export bundle containing a private key encrypted to the client's target public key."
    )


class v1ExportWalletAccountIntent(TurnkeyBaseModel):
    address: str = Field(description="Address to identify Wallet Account.")
    targetPublicKey: str = Field(
        description="Client-side public key generated by the user, to which the export bundle will be encrypted."
    )


class v1ExportWalletAccountRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1ExportWalletAccountIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1ExportWalletAccountResult(TurnkeyBaseModel):
    address: str = Field(description="Address to identify Wallet Account.")
    exportBundle: str = Field(
        description="Export bundle containing a private key encrypted by the client's target public key."
    )


class v1ExportWalletIntent(TurnkeyBaseModel):
    walletId: str = Field(description="Unique identifier for a given Wallet.")
    targetPublicKey: str = Field(
        description="Client-side public key generated by the user, to which the export bundle will be encrypted."
    )
    language: Optional[v1MnemonicLanguage] = Field(
        default=None,
        description="The language of the mnemonic to export. Defaults to English.",
    )


class v1ExportWalletRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1ExportWalletIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1ExportWalletResult(TurnkeyBaseModel):
    walletId: str = Field(description="Unique identifier for a given Wallet.")
    exportBundle: str = Field(
        description="Export bundle containing a wallet mnemonic + optional newline passphrase encrypted by the client's target public key."
    )


class v1Feature(TurnkeyBaseModel):
    name: Optional[v1FeatureName] = Field(default=None)
    value: Optional[str] = Field(default=None)


class v1FeatureName(str, Enum):
    FEATURE_NAME_ROOT_USER_EMAIL_RECOVERY = "FEATURE_NAME_ROOT_USER_EMAIL_RECOVERY"
    FEATURE_NAME_WEBAUTHN_ORIGINS = "FEATURE_NAME_WEBAUTHN_ORIGINS"
    FEATURE_NAME_EMAIL_AUTH = "FEATURE_NAME_EMAIL_AUTH"
    FEATURE_NAME_EMAIL_RECOVERY = "FEATURE_NAME_EMAIL_RECOVERY"
    FEATURE_NAME_WEBHOOK = "FEATURE_NAME_WEBHOOK"
    FEATURE_NAME_SMS_AUTH = "FEATURE_NAME_SMS_AUTH"
    FEATURE_NAME_OTP_EMAIL_AUTH = "FEATURE_NAME_OTP_EMAIL_AUTH"
    FEATURE_NAME_AUTH_PROXY = "FEATURE_NAME_AUTH_PROXY"


class v1FiatOnRampBlockchainNetwork(str, Enum):
    FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_BITCOIN = "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_BITCOIN"
    FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_ETHEREUM = (
        "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_ETHEREUM"
    )
    FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_SOLANA = "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_SOLANA"
    FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_BASE = "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_BASE"


class v1FiatOnRampCredential(TurnkeyBaseModel):
    fiatOnrampCredentialId: str = Field(
        description="Unique identifier for a given Fiat On-Ramp Credential."
    )
    organizationId: str = Field(description="Unique identifier for an Organization.")
    onrampProvider: v1FiatOnRampProvider = Field(
        description="The fiat on-ramp provider."
    )
    projectId: Optional[str] = Field(
        default=None,
        description="Project ID for the on-ramp provider. Some providers, like Coinbase, require this additional identifier.",
    )
    publishableApiKey: str = Field(
        description="Publishable API key for the on-ramp provider."
    )
    encryptedSecretApiKey: str = Field(
        description="Secret API key for the on-ramp provider encrypted to our on-ramp encryption public key."
    )
    encryptedPrivateApiKey: Optional[str] = Field(
        default=None,
        description="Private API key for the on-ramp provider encrypted to our on-ramp encryption public key. Some providers, like Coinbase, require this additional key.",
    )
    sandboxMode: Optional[bool] = Field(
        default=None, description="If the on-ramp credential is a sandbox credential."
    )
    createdAt: externaldatav1Timestamp
    updatedAt: externaldatav1Timestamp


class v1FiatOnRampCryptoCurrency(str, Enum):
    FIAT_ON_RAMP_CRYPTO_CURRENCY_BTC = "FIAT_ON_RAMP_CRYPTO_CURRENCY_BTC"
    FIAT_ON_RAMP_CRYPTO_CURRENCY_ETH = "FIAT_ON_RAMP_CRYPTO_CURRENCY_ETH"
    FIAT_ON_RAMP_CRYPTO_CURRENCY_SOL = "FIAT_ON_RAMP_CRYPTO_CURRENCY_SOL"
    FIAT_ON_RAMP_CRYPTO_CURRENCY_USDC = "FIAT_ON_RAMP_CRYPTO_CURRENCY_USDC"


class v1FiatOnRampCurrency(str, Enum):
    FIAT_ON_RAMP_CURRENCY_AUD = "FIAT_ON_RAMP_CURRENCY_AUD"
    FIAT_ON_RAMP_CURRENCY_BGN = "FIAT_ON_RAMP_CURRENCY_BGN"
    FIAT_ON_RAMP_CURRENCY_BRL = "FIAT_ON_RAMP_CURRENCY_BRL"
    FIAT_ON_RAMP_CURRENCY_CAD = "FIAT_ON_RAMP_CURRENCY_CAD"
    FIAT_ON_RAMP_CURRENCY_CHF = "FIAT_ON_RAMP_CURRENCY_CHF"
    FIAT_ON_RAMP_CURRENCY_COP = "FIAT_ON_RAMP_CURRENCY_COP"
    FIAT_ON_RAMP_CURRENCY_CZK = "FIAT_ON_RAMP_CURRENCY_CZK"
    FIAT_ON_RAMP_CURRENCY_DKK = "FIAT_ON_RAMP_CURRENCY_DKK"
    FIAT_ON_RAMP_CURRENCY_DOP = "FIAT_ON_RAMP_CURRENCY_DOP"
    FIAT_ON_RAMP_CURRENCY_EGP = "FIAT_ON_RAMP_CURRENCY_EGP"
    FIAT_ON_RAMP_CURRENCY_EUR = "FIAT_ON_RAMP_CURRENCY_EUR"
    FIAT_ON_RAMP_CURRENCY_GBP = "FIAT_ON_RAMP_CURRENCY_GBP"
    FIAT_ON_RAMP_CURRENCY_HKD = "FIAT_ON_RAMP_CURRENCY_HKD"
    FIAT_ON_RAMP_CURRENCY_IDR = "FIAT_ON_RAMP_CURRENCY_IDR"
    FIAT_ON_RAMP_CURRENCY_ILS = "FIAT_ON_RAMP_CURRENCY_ILS"
    FIAT_ON_RAMP_CURRENCY_JOD = "FIAT_ON_RAMP_CURRENCY_JOD"
    FIAT_ON_RAMP_CURRENCY_KES = "FIAT_ON_RAMP_CURRENCY_KES"
    FIAT_ON_RAMP_CURRENCY_KWD = "FIAT_ON_RAMP_CURRENCY_KWD"
    FIAT_ON_RAMP_CURRENCY_LKR = "FIAT_ON_RAMP_CURRENCY_LKR"
    FIAT_ON_RAMP_CURRENCY_MXN = "FIAT_ON_RAMP_CURRENCY_MXN"
    FIAT_ON_RAMP_CURRENCY_NGN = "FIAT_ON_RAMP_CURRENCY_NGN"
    FIAT_ON_RAMP_CURRENCY_NOK = "FIAT_ON_RAMP_CURRENCY_NOK"
    FIAT_ON_RAMP_CURRENCY_NZD = "FIAT_ON_RAMP_CURRENCY_NZD"
    FIAT_ON_RAMP_CURRENCY_OMR = "FIAT_ON_RAMP_CURRENCY_OMR"
    FIAT_ON_RAMP_CURRENCY_PEN = "FIAT_ON_RAMP_CURRENCY_PEN"
    FIAT_ON_RAMP_CURRENCY_PLN = "FIAT_ON_RAMP_CURRENCY_PLN"
    FIAT_ON_RAMP_CURRENCY_RON = "FIAT_ON_RAMP_CURRENCY_RON"
    FIAT_ON_RAMP_CURRENCY_SEK = "FIAT_ON_RAMP_CURRENCY_SEK"
    FIAT_ON_RAMP_CURRENCY_THB = "FIAT_ON_RAMP_CURRENCY_THB"
    FIAT_ON_RAMP_CURRENCY_TRY = "FIAT_ON_RAMP_CURRENCY_TRY"
    FIAT_ON_RAMP_CURRENCY_TWD = "FIAT_ON_RAMP_CURRENCY_TWD"
    FIAT_ON_RAMP_CURRENCY_USD = "FIAT_ON_RAMP_CURRENCY_USD"
    FIAT_ON_RAMP_CURRENCY_VND = "FIAT_ON_RAMP_CURRENCY_VND"
    FIAT_ON_RAMP_CURRENCY_ZAR = "FIAT_ON_RAMP_CURRENCY_ZAR"


class v1FiatOnRampPaymentMethod(str, Enum):
    FIAT_ON_RAMP_PAYMENT_METHOD_CREDIT_DEBIT_CARD = (
        "FIAT_ON_RAMP_PAYMENT_METHOD_CREDIT_DEBIT_CARD"
    )
    FIAT_ON_RAMP_PAYMENT_METHOD_APPLE_PAY = "FIAT_ON_RAMP_PAYMENT_METHOD_APPLE_PAY"
    FIAT_ON_RAMP_PAYMENT_METHOD_GBP_BANK_TRANSFER = (
        "FIAT_ON_RAMP_PAYMENT_METHOD_GBP_BANK_TRANSFER"
    )
    FIAT_ON_RAMP_PAYMENT_METHOD_GBP_OPEN_BANKING_PAYMENT = (
        "FIAT_ON_RAMP_PAYMENT_METHOD_GBP_OPEN_BANKING_PAYMENT"
    )
    FIAT_ON_RAMP_PAYMENT_METHOD_GOOGLE_PAY = "FIAT_ON_RAMP_PAYMENT_METHOD_GOOGLE_PAY"
    FIAT_ON_RAMP_PAYMENT_METHOD_SEPA_BANK_TRANSFER = (
        "FIAT_ON_RAMP_PAYMENT_METHOD_SEPA_BANK_TRANSFER"
    )
    FIAT_ON_RAMP_PAYMENT_METHOD_PIX_INSTANT_PAYMENT = (
        "FIAT_ON_RAMP_PAYMENT_METHOD_PIX_INSTANT_PAYMENT"
    )
    FIAT_ON_RAMP_PAYMENT_METHOD_PAYPAL = "FIAT_ON_RAMP_PAYMENT_METHOD_PAYPAL"
    FIAT_ON_RAMP_PAYMENT_METHOD_VENMO = "FIAT_ON_RAMP_PAYMENT_METHOD_VENMO"
    FIAT_ON_RAMP_PAYMENT_METHOD_MOONPAY_BALANCE = (
        "FIAT_ON_RAMP_PAYMENT_METHOD_MOONPAY_BALANCE"
    )
    FIAT_ON_RAMP_PAYMENT_METHOD_CRYPTO_ACCOUNT = (
        "FIAT_ON_RAMP_PAYMENT_METHOD_CRYPTO_ACCOUNT"
    )
    FIAT_ON_RAMP_PAYMENT_METHOD_FIAT_WALLET = "FIAT_ON_RAMP_PAYMENT_METHOD_FIAT_WALLET"
    FIAT_ON_RAMP_PAYMENT_METHOD_ACH_BANK_ACCOUNT = (
        "FIAT_ON_RAMP_PAYMENT_METHOD_ACH_BANK_ACCOUNT"
    )


class v1FiatOnRampProvider(str, Enum):
    FIAT_ON_RAMP_PROVIDER_COINBASE = "FIAT_ON_RAMP_PROVIDER_COINBASE"
    FIAT_ON_RAMP_PROVIDER_MOONPAY = "FIAT_ON_RAMP_PROVIDER_MOONPAY"


class v1GetActivitiesRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )
    filterByStatus: Optional[List[v1ActivityStatus]] = Field(
        default=None,
        description="Array of activity statuses filtering which activities will be listed in the response.",
    )
    paginationOptions: Optional[v1Pagination] = Field(
        default=None, description="Parameters used for cursor-based pagination."
    )
    filterByType: Optional[List[v1ActivityType]] = Field(
        default=None,
        description="Array of activity types filtering which activities will be listed in the response.",
    )


class v1GetActivitiesResponse(TurnkeyBaseModel):
    activities: List[v1Activity] = Field(description="A list of activities.")


class v1GetActivityRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )
    activityId: str = Field(
        description="Unique identifier for a given activity object."
    )


class v1GetApiKeyRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )
    apiKeyId: str = Field(description="Unique identifier for a given API key.")


class v1GetApiKeyResponse(TurnkeyBaseModel):
    apiKey: v1ApiKey = Field(description="An API key.")


class v1GetApiKeysRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )
    userId: Optional[str] = Field(
        default=None, description="Unique identifier for a given user."
    )


class v1GetApiKeysResponse(TurnkeyBaseModel):
    apiKeys: List[v1ApiKey] = Field(description="A list of API keys.")


class v1GetAppProofsRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    activityId: str = Field(description="Unique identifier for a given activity.")


class v1GetAppProofsResponse(TurnkeyBaseModel):
    appProofs: List[v1AppProof]


class v1GetAttestationDocumentRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )
    enclaveType: str = Field(
        description="The enclave type, one of: ump, notarizer, signer, evm-parser."
    )


class v1GetAttestationDocumentResponse(TurnkeyBaseModel):
    attestationDocument: str = Field(
        description="Raw (CBOR-encoded) attestation document."
    )


class v1GetAuthenticatorRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )
    authenticatorId: str = Field(
        description="Unique identifier for a given authenticator."
    )


class v1GetAuthenticatorResponse(TurnkeyBaseModel):
    authenticator: v1Authenticator = Field(description="An authenticator.")


class v1GetAuthenticatorsRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )
    userId: str = Field(description="Unique identifier for a given user.")


class v1GetAuthenticatorsResponse(TurnkeyBaseModel):
    authenticators: List[v1Authenticator] = Field(
        description="A list of authenticators."
    )


class v1GetBootProofRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    ephemeralKey: str = Field(description="Hex encoded ephemeral public key.")


class v1GetGasUsageRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )


class v1GetGasUsageResponse(TurnkeyBaseModel):
    windowDurationMinutes: int = Field(
        description="The window duration (in minutes) for the organization or sub-organization."
    )
    windowLimitUsd: str = Field(
        description="The window limit (in USD) for the organization or sub-organization."
    )
    usageUsd: str = Field(
        description="The total gas usage (in USD) of all sponsored transactions processed over the last `window_duration_minutes`"
    )


class v1GetLatestBootProofRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    appName: str = Field(description="Name of enclave app.")


class v1GetNoncesRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    address: str = Field(description="The Ethereum address to query nonces for.")
    caip2: str = Field(
        description="The network identifier in CAIP-2 format (e.g., 'eip155:1' for Ethereum mainnet)."
    )
    nonce: Optional[bool] = Field(
        default=None, description="Whether to fetch the standard on-chain nonce."
    )
    gasStationNonce: Optional[bool] = Field(
        default=None,
        description="Whether to fetch the gas station nonce used for sponsored transactions.",
    )


class v1GetNoncesResponse(TurnkeyBaseModel):
    nonce: Optional[str] = Field(
        default=None,
        description="The standard on-chain nonce for the address, if requested.",
    )
    gasStationNonce: Optional[str] = Field(
        default=None,
        description="The gas station nonce for sponsored transactions, if requested.",
    )


class v1GetOauth2CredentialRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    oauth2CredentialId: str = Field(
        description="Unique identifier for a given OAuth 2.0 Credential."
    )


class v1GetOauth2CredentialResponse(TurnkeyBaseModel):
    oauth2Credential: v1Oauth2Credential


class v1GetOauthProvidersRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )
    userId: Optional[str] = Field(
        default=None, description="Unique identifier for a given user."
    )


class v1GetOauthProvidersResponse(TurnkeyBaseModel):
    oauthProviders: List[v1OauthProvider] = Field(
        description="A list of Oauth providers."
    )


class v1GetOnRampTransactionStatusRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )
    transactionId: str = Field(
        description="The unique identifier for the fiat on ramp transaction."
    )
    refresh: Optional[bool] = Field(
        default=None,
        description="Optional flag to specify if the transaction status should be refreshed from the fiat on ramp provider. Default = false.",
    )


class v1GetOnRampTransactionStatusResponse(TurnkeyBaseModel):
    transactionStatus: str = Field(
        description="The status of the fiat on ramp transaction."
    )


class v1GetOrganizationConfigsRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )


class v1GetOrganizationConfigsResponse(TurnkeyBaseModel):
    configs: v1Config = Field(
        description="Organization configs including quorum settings and organization features."
    )


class v1GetOrganizationRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )


class v1GetOrganizationResponse(TurnkeyBaseModel):
    organizationData: v1OrganizationData = Field(
        description="Object representing the full current and deleted / disabled collection of users, policies, private keys, and invitations attributable to a particular organization."
    )


class v1GetPoliciesRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )


class v1GetPoliciesResponse(TurnkeyBaseModel):
    policies: List[v1Policy] = Field(description="A list of policies.")


class v1GetPolicyEvaluationsRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )
    activityId: str = Field(description="Unique identifier for a given activity.")


class v1GetPolicyEvaluationsResponse(TurnkeyBaseModel):
    policyEvaluations: List[externalactivityv1PolicyEvaluation]


class v1GetPolicyRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )
    policyId: str = Field(description="Unique identifier for a given policy.")


class v1GetPolicyResponse(TurnkeyBaseModel):
    policy: v1Policy = Field(
        description="Object that codifies rules defining the actions that are permissible within an organization."
    )


class v1GetPrivateKeyRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )
    privateKeyId: str = Field(description="Unique identifier for a given private key.")


class v1GetPrivateKeyResponse(TurnkeyBaseModel):
    privateKey: v1PrivateKey = Field(
        description="Cryptographic public/private key pair that can be used for cryptocurrency needs or more generalized encryption."
    )


class v1GetPrivateKeysRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )


class v1GetPrivateKeysResponse(TurnkeyBaseModel):
    privateKeys: List[v1PrivateKey] = Field(description="A list of private keys.")


class v1GetSendTransactionStatusRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )
    sendTransactionStatusId: str = Field(
        description="The unique identifier of a send transaction request."
    )


class v1GetSendTransactionStatusResponse(TurnkeyBaseModel):
    txStatus: str = Field(description="The current status of the send transaction.")
    eth: Optional[v1EthSendTransactionStatus] = Field(
        default=None, description="Ethereum-specific transaction status."
    )
    txError: Optional[str] = Field(
        default=None,
        description="The error encountered when broadcasting or confirming the transaction, if any.",
    )


class v1GetSmartContractInterfaceRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )
    smartContractInterfaceId: str = Field(
        description="Unique identifier for a given smart contract interface."
    )


class v1GetSmartContractInterfaceResponse(TurnkeyBaseModel):
    smartContractInterface: externaldatav1SmartContractInterface = Field(
        description="Object to be used in conjunction with policies to guard transaction signing."
    )


class v1GetSmartContractInterfacesRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )


class v1GetSmartContractInterfacesResponse(TurnkeyBaseModel):
    smartContractInterfaces: List[externaldatav1SmartContractInterface] = Field(
        description="A list of smart contract interfaces."
    )


class v1GetSubOrgIdsRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for the parent organization. This is used to find sub-organizations within it."
    )
    filterType: Optional[str] = Field(
        default=None,
        description="Specifies the type of filter to apply, i.e 'CREDENTIAL_ID', 'NAME', 'USERNAME', 'EMAIL', 'PHONE_NUMBER', 'OIDC_TOKEN', 'WALLET_ACCOUNT_ADDRESS' or 'PUBLIC_KEY'",
    )
    filterValue: Optional[str] = Field(
        default=None,
        description="The value of the filter to apply for the specified type. For example, a specific email or name string.",
    )
    paginationOptions: Optional[v1Pagination] = Field(
        default=None, description="Parameters used for cursor-based pagination."
    )


class v1GetSubOrgIdsResponse(TurnkeyBaseModel):
    organizationIds: List[str] = Field(
        description="List of unique identifiers for the matching sub-organizations."
    )


class v1GetUserRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )
    userId: str = Field(description="Unique identifier for a given user.")


class v1GetUserResponse(TurnkeyBaseModel):
    user: v1User = Field(description="Web and/or API user within your organization.")


class v1GetUsersRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )


class v1GetUsersResponse(TurnkeyBaseModel):
    users: List[v1User] = Field(description="A list of users.")


class v1GetVerifiedSubOrgIdsRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for the parent organization. This is used to find sub-organizations within it."
    )
    filterType: Optional[str] = Field(
        default=None,
        description="Specifies the type of filter to apply, i.e 'EMAIL', 'PHONE_NUMBER'.",
    )
    filterValue: Optional[str] = Field(
        default=None,
        description="The value of the filter to apply for the specified type. For example, a specific email or phone number string.",
    )
    paginationOptions: Optional[v1Pagination] = Field(
        default=None, description="Parameters used for cursor-based pagination."
    )


class v1GetVerifiedSubOrgIdsResponse(TurnkeyBaseModel):
    organizationIds: List[str] = Field(
        description="List of unique identifiers for the matching sub-organizations."
    )


class v1GetWalletAccountRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )
    walletId: str = Field(description="Unique identifier for a given wallet.")
    address: Optional[str] = Field(
        default=None, description="Address corresponding to a wallet account."
    )
    path: Optional[str] = Field(
        default=None, description="Path corresponding to a wallet account."
    )


class v1GetWalletAccountResponse(TurnkeyBaseModel):
    account: v1WalletAccount = Field(description="The resulting wallet account.")


class v1GetWalletAccountsRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )
    walletId: Optional[str] = Field(
        default=None,
        description="Unique identifier for a given wallet. If not provided, all accounts for the organization will be returned.",
    )
    includeWalletDetails: Optional[bool] = Field(
        default=None,
        description="Optional flag to specify if the wallet details should be included in the response. Default = false.",
    )
    paginationOptions: Optional[v1Pagination] = Field(
        default=None, description="Parameters used for cursor-based pagination."
    )


class v1GetWalletAccountsResponse(TurnkeyBaseModel):
    accounts: List[v1WalletAccount] = Field(
        description="A list of accounts generated from a wallet that share a common seed."
    )


class v1GetWalletRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )
    walletId: str = Field(description="Unique identifier for a given wallet.")


class v1GetWalletResponse(TurnkeyBaseModel):
    wallet: v1Wallet = Field(
        description="A collection of deterministically generated cryptographic public / private key pairs that share a common seed."
    )


class v1GetWalletsRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )


class v1GetWalletsResponse(TurnkeyBaseModel):
    wallets: List[v1Wallet] = Field(description="A list of wallets.")


class v1GetWhoamiRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization. If the request is being made by a WebAuthN user and their sub-organization ID is unknown, this can be the parent organization ID; using the sub-organization ID when possible is preferred due to performance reasons."
    )


class v1GetWhoamiResponse(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )
    organizationName: str = Field(
        description="Human-readable name for an organization."
    )
    userId: str = Field(description="Unique identifier for a given user.")
    username: str = Field(description="Human-readable name for a user.")


class v1HashFunction(str, Enum):
    HASH_FUNCTION_NO_OP = "HASH_FUNCTION_NO_OP"
    HASH_FUNCTION_SHA256 = "HASH_FUNCTION_SHA256"
    HASH_FUNCTION_KECCAK256 = "HASH_FUNCTION_KECCAK256"
    HASH_FUNCTION_NOT_APPLICABLE = "HASH_FUNCTION_NOT_APPLICABLE"


class v1ImportPrivateKeyIntent(TurnkeyBaseModel):
    userId: str = Field(description="The ID of the User importing a Private Key.")
    privateKeyName: str = Field(description="Human-readable name for a Private Key.")
    encryptedBundle: str = Field(
        description="Bundle containing a raw private key encrypted to the enclave's target public key."
    )
    curve: v1Curve = Field(
        description="Cryptographic Curve used to generate a given Private Key."
    )
    addressFormats: List[v1AddressFormat] = Field(
        description="Cryptocurrency-specific formats for a derived address (e.g., Ethereum)."
    )


class v1ImportPrivateKeyRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1ImportPrivateKeyIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1ImportPrivateKeyResult(TurnkeyBaseModel):
    privateKeyId: str = Field(description="Unique identifier for a Private Key.")
    addresses: List[immutableactivityv1Address] = Field(
        description="A list of addresses."
    )


class v1ImportWalletIntent(TurnkeyBaseModel):
    userId: str = Field(description="The ID of the User importing a Wallet.")
    walletName: str = Field(description="Human-readable name for a Wallet.")
    encryptedBundle: str = Field(
        description="Bundle containing a wallet mnemonic encrypted to the enclave's target public key."
    )
    accounts: List[v1WalletAccountParams] = Field(
        description="A list of wallet Accounts."
    )


class v1ImportWalletRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1ImportWalletIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1ImportWalletResult(TurnkeyBaseModel):
    walletId: str = Field(description="Unique identifier for a Wallet.")
    addresses: List[str] = Field(description="A list of account addresses.")


class v1InitFiatOnRampIntent(TurnkeyBaseModel):
    onrampProvider: v1FiatOnRampProvider = Field(
        description="Enum to specifiy which on-ramp provider to use"
    )
    walletAddress: str = Field(
        description="Destination wallet address for the buy transaction."
    )
    network: v1FiatOnRampBlockchainNetwork = Field(
        description="Blockchain network to be used for the transaction, e.g., bitcoin, ethereum. Maps to MoonPay's network or Coinbase's defaultNetwork."
    )
    cryptoCurrencyCode: v1FiatOnRampCryptoCurrency = Field(
        description="Code for the cryptocurrency to be purchased, e.g., btc, eth. Maps to MoonPay's currencyCode or Coinbase's defaultAsset."
    )
    fiatCurrencyCode: Optional[v1FiatOnRampCurrency] = Field(
        default=None,
        description="Code for the fiat currency to be used in the transaction, e.g., USD, EUR.",
    )
    fiatCurrencyAmount: Optional[str] = Field(
        default=None,
        description="Specifies a preset fiat amount for the transaction, e.g., '100'. Must be greater than '20'. If not provided, the user will be prompted to enter an amount.",
    )
    paymentMethod: Optional[v1FiatOnRampPaymentMethod] = Field(
        default=None,
        description="Pre-selected payment method, e.g., CREDIT_DEBIT_CARD, APPLE_PAY. Validated against the chosen provider.",
    )
    countryCode: Optional[str] = Field(
        default=None,
        description="ISO 3166-1 two-digit country code for Coinbase representing the purchasing users country of residence, e.g., US, GB.",
    )
    countrySubdivisionCode: Optional[str] = Field(
        default=None,
        description="ISO 3166-2 two-digit country subdivision code for Coinbase representing the purchasing users subdivision of residence within their country, e.g. NY. Required if country_code=US.",
    )
    sandboxMode: Optional[bool] = Field(
        default=None,
        description="Optional flag to indicate whether to use the sandbox mode to simulate transactions for the on-ramp provider. Default is false.",
    )
    urlForSignature: Optional[str] = Field(
        default=None,
        description="Optional MoonPay Widget URL to sign when using MoonPay client SDKs with URL Signing enabled.",
    )


class v1InitFiatOnRampRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1InitFiatOnRampIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1InitFiatOnRampResult(TurnkeyBaseModel):
    onRampUrl: str = Field(description="Unique URL for a given fiat on-ramp flow.")
    onRampTransactionId: str = Field(
        description="Unique identifier used to retrieve transaction statuses for a given fiat on-ramp flow."
    )
    onRampUrlSignature: Optional[str] = Field(
        default=None,
        description="Optional signature of the MoonPay Widget URL. The signature is generated if the Init Fiat On Ramp intent includes the urlForSignature field. The signature can be used to initialize the MoonPay SDKs when URL signing is enabled for your project.",
    )


class v1InitImportPrivateKeyIntent(TurnkeyBaseModel):
    userId: str = Field(description="The ID of the User importing a Private Key.")


class v1InitImportPrivateKeyRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1InitImportPrivateKeyIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1InitImportPrivateKeyResult(TurnkeyBaseModel):
    importBundle: str = Field(
        description="Import bundle containing a public key and signature to use for importing client data."
    )


class v1InitImportWalletIntent(TurnkeyBaseModel):
    userId: str = Field(description="The ID of the User importing a Wallet.")


class v1InitImportWalletRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1InitImportWalletIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1InitImportWalletResult(TurnkeyBaseModel):
    importBundle: str = Field(
        description="Import bundle containing a public key and signature to use for importing client data."
    )


class v1InitOtpAuthIntent(TurnkeyBaseModel):
    otpType: str = Field(
        description="Enum to specifiy whether to send OTP via SMS or email"
    )
    contact: str = Field(description="Email or phone number to send the OTP code to")
    emailCustomization: Optional[v1EmailCustomizationParams] = Field(
        default=None,
        description="Optional parameters for customizing emails. If not provided, the default email will be used.",
    )
    smsCustomization: Optional[v1SmsCustomizationParams] = Field(
        default=None,
        description="Optional parameters for customizing SMS message. If not provided, the default sms message will be used.",
    )
    userIdentifier: Optional[str] = Field(
        default=None,
        description="Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address.",
    )
    sendFromEmailAddress: Optional[str] = Field(
        default=None,
        description="Optional custom email address from which to send the OTP email",
    )
    sendFromEmailSenderName: Optional[str] = Field(
        default=None,
        description="Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'",
    )
    replyToEmailAddress: Optional[str] = Field(
        default=None, description="Optional custom email address to use as reply-to"
    )


class v1InitOtpAuthIntentV2(TurnkeyBaseModel):
    otpType: str = Field(
        description="Enum to specifiy whether to send OTP via SMS or email"
    )
    contact: str = Field(description="Email or phone number to send the OTP code to")
    otpLength: Optional[int] = Field(
        default=None, description="Optional length of the OTP code. Default = 9"
    )
    emailCustomization: Optional[v1EmailCustomizationParams] = Field(
        default=None,
        description="Optional parameters for customizing emails. If not provided, the default email will be used.",
    )
    smsCustomization: Optional[v1SmsCustomizationParams] = Field(
        default=None,
        description="Optional parameters for customizing SMS message. If not provided, the default SMS message will be used.",
    )
    userIdentifier: Optional[str] = Field(
        default=None,
        description="Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address.",
    )
    sendFromEmailAddress: Optional[str] = Field(
        default=None,
        description="Optional custom email address from which to send the OTP email",
    )
    alphanumeric: Optional[bool] = Field(
        default=None,
        description="Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true",
    )
    sendFromEmailSenderName: Optional[str] = Field(
        default=None,
        description="Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'",
    )
    replyToEmailAddress: Optional[str] = Field(
        default=None, description="Optional custom email address to use as reply-to"
    )


class v1InitOtpAuthIntentV3(TurnkeyBaseModel):
    otpType: str = Field(
        description="Whether to send OTP via SMS or email. Possible values: OTP_TYPE_SMS, OTP_TYPE_EMAIL"
    )
    contact: str = Field(description="Email or phone number to send the OTP code to")
    otpLength: Optional[int] = Field(
        default=None, description="Optional length of the OTP code. Default = 9"
    )
    appName: str = Field(
        description="The name of the application. This field is required and will be used in email notifications if an email template is not provided."
    )
    emailCustomization: Optional[v1EmailCustomizationParamsV2] = Field(
        default=None,
        description="Optional parameters for customizing emails. If not provided, the default email will be used.",
    )
    smsCustomization: Optional[v1SmsCustomizationParams] = Field(
        default=None,
        description="Optional parameters for customizing SMS message. If not provided, the default SMS message will be used.",
    )
    userIdentifier: Optional[str] = Field(
        default=None,
        description="Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address.",
    )
    sendFromEmailAddress: Optional[str] = Field(
        default=None,
        description="Optional custom email address from which to send the OTP email",
    )
    alphanumeric: Optional[bool] = Field(
        default=None,
        description="Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true",
    )
    sendFromEmailSenderName: Optional[str] = Field(
        default=None,
        description="Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'",
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the OTP is valid for. If not provided, a default of 5 minutes will be used. Maximum value is 600 seconds (10 minutes)",
    )
    replyToEmailAddress: Optional[str] = Field(
        default=None, description="Optional custom email address to use as reply-to"
    )


class v1InitOtpAuthRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1InitOtpAuthIntentV3
    generateAppProofs: Optional[bool] = Field(default=None)


class v1InitOtpAuthResult(TurnkeyBaseModel):
    otpId: str = Field(description="Unique identifier for an OTP authentication")


class v1InitOtpAuthResultV2(TurnkeyBaseModel):
    otpId: str = Field(description="Unique identifier for an OTP authentication")


class v1InitOtpIntent(TurnkeyBaseModel):
    otpType: str = Field(
        description="Whether to send OTP via SMS or email. Possible values: OTP_TYPE_SMS, OTP_TYPE_EMAIL"
    )
    contact: str = Field(description="Email or phone number to send the OTP code to")
    otpLength: Optional[int] = Field(
        default=None, description="Optional length of the OTP code. Default = 9"
    )
    emailCustomization: Optional[v1EmailCustomizationParams] = Field(
        default=None,
        description="Optional parameters for customizing emails. If not provided, the default email will be used.",
    )
    smsCustomization: Optional[v1SmsCustomizationParams] = Field(
        default=None,
        description="Optional parameters for customizing SMS message. If not provided, the default sms message will be used.",
    )
    userIdentifier: Optional[str] = Field(
        default=None,
        description="Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address.",
    )
    sendFromEmailAddress: Optional[str] = Field(
        default=None,
        description="Optional custom email address from which to send the OTP email",
    )
    alphanumeric: Optional[bool] = Field(
        default=None,
        description="Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true",
    )
    sendFromEmailSenderName: Optional[str] = Field(
        default=None,
        description="Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'",
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the OTP is valid for. If not provided, a default of 5 minutes will be used. Maximum value is 600 seconds (10 minutes)",
    )
    replyToEmailAddress: Optional[str] = Field(
        default=None, description="Optional custom email address to use as reply-to"
    )


class v1InitOtpIntentV2(TurnkeyBaseModel):
    otpType: str = Field(
        description="Whether to send OTP via SMS or email. Possible values: OTP_TYPE_SMS, OTP_TYPE_EMAIL"
    )
    contact: str = Field(description="Email or phone number to send the OTP code to")
    otpLength: Optional[int] = Field(
        default=None, description="Optional length of the OTP code. Default = 9"
    )
    appName: str = Field(
        description="The name of the application. This field is required and will be used in email notifications if an email template is not provided."
    )
    emailCustomization: Optional[v1EmailCustomizationParamsV2] = Field(
        default=None,
        description="Optional parameters for customizing emails. If not provided, the default email will be used.",
    )
    smsCustomization: Optional[v1SmsCustomizationParams] = Field(
        default=None,
        description="Optional parameters for customizing SMS message. If not provided, the default SMS message will be used.",
    )
    userIdentifier: Optional[str] = Field(
        default=None,
        description="Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address.",
    )
    sendFromEmailAddress: Optional[str] = Field(
        default=None,
        description="Optional custom email address from which to send the OTP email",
    )
    alphanumeric: Optional[bool] = Field(
        default=None,
        description="Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true",
    )
    sendFromEmailSenderName: Optional[str] = Field(
        default=None,
        description="Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'",
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the OTP is valid for. If not provided, a default of 5 minutes will be used. Maximum value is 600 seconds (10 minutes)",
    )
    replyToEmailAddress: Optional[str] = Field(
        default=None, description="Optional custom email address to use as reply-to"
    )


class v1InitOtpRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1InitOtpIntentV2
    generateAppProofs: Optional[bool] = Field(default=None)


class v1InitOtpResult(TurnkeyBaseModel):
    otpId: str = Field(description="Unique identifier for an OTP authentication")


class v1InitUserEmailRecoveryIntent(TurnkeyBaseModel):
    email: str = Field(description="Email of the user starting recovery")
    targetPublicKey: str = Field(
        description="Client-side public key generated by the user, to which the recovery bundle will be encrypted."
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the recovery credential is valid for. If not provided, a default of 15 minutes will be used.",
    )
    emailCustomization: Optional[v1EmailCustomizationParams] = Field(
        default=None,
        description="Optional parameters for customizing emails. If not provided, the default email will be used.",
    )
    sendFromEmailAddress: Optional[str] = Field(
        default=None,
        description="Optional custom email address from which to send the OTP email",
    )
    sendFromEmailSenderName: Optional[str] = Field(
        default=None,
        description="Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'",
    )
    replyToEmailAddress: Optional[str] = Field(
        default=None, description="Optional custom email address to use as reply-to"
    )


class v1InitUserEmailRecoveryIntentV2(TurnkeyBaseModel):
    email: str = Field(description="Email of the user starting recovery")
    targetPublicKey: str = Field(
        description="Client-side public key generated by the user, to which the recovery bundle will be encrypted."
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the recovery credential is valid for. If not provided, a default of 15 minutes will be used.",
    )
    emailCustomization: v1EmailAuthCustomizationParams = Field(
        description="Parameters for customizing emails. If not provided, the default email will be used. Note that `app_name` is required."
    )
    sendFromEmailAddress: Optional[str] = Field(
        default=None,
        description="Optional custom email address from which to send the OTP email",
    )
    sendFromEmailSenderName: Optional[str] = Field(
        default=None,
        description="Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'",
    )
    replyToEmailAddress: Optional[str] = Field(
        default=None, description="Optional custom email address to use as reply-to"
    )


class v1InitUserEmailRecoveryRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1InitUserEmailRecoveryIntentV2
    generateAppProofs: Optional[bool] = Field(default=None)


class v1InitUserEmailRecoveryResult(TurnkeyBaseModel):
    userId: str = Field(description="Unique identifier for the user being recovered.")


class v1Intent(TurnkeyBaseModel):
    createOrganizationIntent: Optional[v1CreateOrganizationIntent] = Field(default=None)
    createAuthenticatorsIntent: Optional[v1CreateAuthenticatorsIntent] = Field(
        default=None
    )
    createUsersIntent: Optional[v1CreateUsersIntent] = Field(default=None)
    createPrivateKeysIntent: Optional[v1CreatePrivateKeysIntent] = Field(default=None)
    signRawPayloadIntent: Optional[v1SignRawPayloadIntent] = Field(default=None)
    createInvitationsIntent: Optional[v1CreateInvitationsIntent] = Field(default=None)
    acceptInvitationIntent: Optional[v1AcceptInvitationIntent] = Field(default=None)
    createPolicyIntent: Optional[v1CreatePolicyIntent] = Field(default=None)
    disablePrivateKeyIntent: Optional[v1DisablePrivateKeyIntent] = Field(default=None)
    deleteUsersIntent: Optional[v1DeleteUsersIntent] = Field(default=None)
    deleteAuthenticatorsIntent: Optional[v1DeleteAuthenticatorsIntent] = Field(
        default=None
    )
    deleteInvitationIntent: Optional[v1DeleteInvitationIntent] = Field(default=None)
    deleteOrganizationIntent: Optional[v1DeleteOrganizationIntent] = Field(default=None)
    deletePolicyIntent: Optional[v1DeletePolicyIntent] = Field(default=None)
    createUserTagIntent: Optional[v1CreateUserTagIntent] = Field(default=None)
    deleteUserTagsIntent: Optional[v1DeleteUserTagsIntent] = Field(default=None)
    signTransactionIntent: Optional[v1SignTransactionIntent] = Field(default=None)
    createApiKeysIntent: Optional[v1CreateApiKeysIntent] = Field(default=None)
    deleteApiKeysIntent: Optional[v1DeleteApiKeysIntent] = Field(default=None)
    approveActivityIntent: Optional[v1ApproveActivityIntent] = Field(default=None)
    rejectActivityIntent: Optional[v1RejectActivityIntent] = Field(default=None)
    createPrivateKeyTagIntent: Optional[v1CreatePrivateKeyTagIntent] = Field(
        default=None
    )
    deletePrivateKeyTagsIntent: Optional[v1DeletePrivateKeyTagsIntent] = Field(
        default=None
    )
    createPolicyIntentV2: Optional[v1CreatePolicyIntentV2] = Field(default=None)
    setPaymentMethodIntent: Optional[billingSetPaymentMethodIntent] = Field(
        default=None
    )
    activateBillingTierIntent: Optional[billingActivateBillingTierIntent] = Field(
        default=None
    )
    deletePaymentMethodIntent: Optional[billingDeletePaymentMethodIntent] = Field(
        default=None
    )
    createPolicyIntentV3: Optional[v1CreatePolicyIntentV3] = Field(default=None)
    createApiOnlyUsersIntent: Optional[v1CreateApiOnlyUsersIntent] = Field(default=None)
    updateRootQuorumIntent: Optional[v1UpdateRootQuorumIntent] = Field(default=None)
    updateUserTagIntent: Optional[v1UpdateUserTagIntent] = Field(default=None)
    updatePrivateKeyTagIntent: Optional[v1UpdatePrivateKeyTagIntent] = Field(
        default=None
    )
    createAuthenticatorsIntentV2: Optional[v1CreateAuthenticatorsIntentV2] = Field(
        default=None
    )
    acceptInvitationIntentV2: Optional[v1AcceptInvitationIntentV2] = Field(default=None)
    createOrganizationIntentV2: Optional[v1CreateOrganizationIntentV2] = Field(
        default=None
    )
    createUsersIntentV2: Optional[v1CreateUsersIntentV2] = Field(default=None)
    createSubOrganizationIntent: Optional[v1CreateSubOrganizationIntent] = Field(
        default=None
    )
    createSubOrganizationIntentV2: Optional[v1CreateSubOrganizationIntentV2] = Field(
        default=None
    )
    updateAllowedOriginsIntent: Optional[v1UpdateAllowedOriginsIntent] = Field(
        default=None
    )
    createPrivateKeysIntentV2: Optional[v1CreatePrivateKeysIntentV2] = Field(
        default=None
    )
    updateUserIntent: Optional[v1UpdateUserIntent] = Field(default=None)
    updatePolicyIntent: Optional[v1UpdatePolicyIntent] = Field(default=None)
    setPaymentMethodIntentV2: Optional[billingSetPaymentMethodIntentV2] = Field(
        default=None
    )
    createSubOrganizationIntentV3: Optional[v1CreateSubOrganizationIntentV3] = Field(
        default=None
    )
    createWalletIntent: Optional[v1CreateWalletIntent] = Field(default=None)
    createWalletAccountsIntent: Optional[v1CreateWalletAccountsIntent] = Field(
        default=None
    )
    initUserEmailRecoveryIntent: Optional[v1InitUserEmailRecoveryIntent] = Field(
        default=None
    )
    recoverUserIntent: Optional[v1RecoverUserIntent] = Field(default=None)
    setOrganizationFeatureIntent: Optional[v1SetOrganizationFeatureIntent] = Field(
        default=None
    )
    removeOrganizationFeatureIntent: Optional[v1RemoveOrganizationFeatureIntent] = (
        Field(default=None)
    )
    signRawPayloadIntentV2: Optional[v1SignRawPayloadIntentV2] = Field(default=None)
    signTransactionIntentV2: Optional[v1SignTransactionIntentV2] = Field(default=None)
    exportPrivateKeyIntent: Optional[v1ExportPrivateKeyIntent] = Field(default=None)
    exportWalletIntent: Optional[v1ExportWalletIntent] = Field(default=None)
    createSubOrganizationIntentV4: Optional[v1CreateSubOrganizationIntentV4] = Field(
        default=None
    )
    emailAuthIntent: Optional[v1EmailAuthIntent] = Field(default=None)
    exportWalletAccountIntent: Optional[v1ExportWalletAccountIntent] = Field(
        default=None
    )
    initImportWalletIntent: Optional[v1InitImportWalletIntent] = Field(default=None)
    importWalletIntent: Optional[v1ImportWalletIntent] = Field(default=None)
    initImportPrivateKeyIntent: Optional[v1InitImportPrivateKeyIntent] = Field(
        default=None
    )
    importPrivateKeyIntent: Optional[v1ImportPrivateKeyIntent] = Field(default=None)
    createPoliciesIntent: Optional[v1CreatePoliciesIntent] = Field(default=None)
    signRawPayloadsIntent: Optional[v1SignRawPayloadsIntent] = Field(default=None)
    createReadOnlySessionIntent: Optional[v1CreateReadOnlySessionIntent] = Field(
        default=None
    )
    createOauthProvidersIntent: Optional[v1CreateOauthProvidersIntent] = Field(
        default=None
    )
    deleteOauthProvidersIntent: Optional[v1DeleteOauthProvidersIntent] = Field(
        default=None
    )
    createSubOrganizationIntentV5: Optional[v1CreateSubOrganizationIntentV5] = Field(
        default=None
    )
    oauthIntent: Optional[v1OauthIntent] = Field(default=None)
    createApiKeysIntentV2: Optional[v1CreateApiKeysIntentV2] = Field(default=None)
    createReadWriteSessionIntent: Optional[v1CreateReadWriteSessionIntent] = Field(
        default=None
    )
    emailAuthIntentV2: Optional[v1EmailAuthIntentV2] = Field(default=None)
    createSubOrganizationIntentV6: Optional[v1CreateSubOrganizationIntentV6] = Field(
        default=None
    )
    deletePrivateKeysIntent: Optional[v1DeletePrivateKeysIntent] = Field(default=None)
    deleteWalletsIntent: Optional[v1DeleteWalletsIntent] = Field(default=None)
    createReadWriteSessionIntentV2: Optional[v1CreateReadWriteSessionIntentV2] = Field(
        default=None
    )
    deleteSubOrganizationIntent: Optional[v1DeleteSubOrganizationIntent] = Field(
        default=None
    )
    initOtpAuthIntent: Optional[v1InitOtpAuthIntent] = Field(default=None)
    otpAuthIntent: Optional[v1OtpAuthIntent] = Field(default=None)
    createSubOrganizationIntentV7: Optional[v1CreateSubOrganizationIntentV7] = Field(
        default=None
    )
    updateWalletIntent: Optional[v1UpdateWalletIntent] = Field(default=None)
    updatePolicyIntentV2: Optional[v1UpdatePolicyIntentV2] = Field(default=None)
    createUsersIntentV3: Optional[v1CreateUsersIntentV3] = Field(default=None)
    initOtpAuthIntentV2: Optional[v1InitOtpAuthIntentV2] = Field(default=None)
    initOtpIntent: Optional[v1InitOtpIntent] = Field(default=None)
    verifyOtpIntent: Optional[v1VerifyOtpIntent] = Field(default=None)
    otpLoginIntent: Optional[v1OtpLoginIntent] = Field(default=None)
    stampLoginIntent: Optional[v1StampLoginIntent] = Field(default=None)
    oauthLoginIntent: Optional[v1OauthLoginIntent] = Field(default=None)
    updateUserNameIntent: Optional[v1UpdateUserNameIntent] = Field(default=None)
    updateUserEmailIntent: Optional[v1UpdateUserEmailIntent] = Field(default=None)
    updateUserPhoneNumberIntent: Optional[v1UpdateUserPhoneNumberIntent] = Field(
        default=None
    )
    initFiatOnRampIntent: Optional[v1InitFiatOnRampIntent] = Field(default=None)
    createSmartContractInterfaceIntent: Optional[
        v1CreateSmartContractInterfaceIntent
    ] = Field(default=None)
    deleteSmartContractInterfaceIntent: Optional[
        v1DeleteSmartContractInterfaceIntent
    ] = Field(default=None)
    enableAuthProxyIntent: Optional[v1EnableAuthProxyIntent] = Field(default=None)
    disableAuthProxyIntent: Optional[v1DisableAuthProxyIntent] = Field(default=None)
    updateAuthProxyConfigIntent: Optional[v1UpdateAuthProxyConfigIntent] = Field(
        default=None
    )
    createOauth2CredentialIntent: Optional[v1CreateOauth2CredentialIntent] = Field(
        default=None
    )
    updateOauth2CredentialIntent: Optional[v1UpdateOauth2CredentialIntent] = Field(
        default=None
    )
    deleteOauth2CredentialIntent: Optional[v1DeleteOauth2CredentialIntent] = Field(
        default=None
    )
    oauth2AuthenticateIntent: Optional[v1Oauth2AuthenticateIntent] = Field(default=None)
    deleteWalletAccountsIntent: Optional[v1DeleteWalletAccountsIntent] = Field(
        default=None
    )
    deletePoliciesIntent: Optional[v1DeletePoliciesIntent] = Field(default=None)
    ethSendRawTransactionIntent: Optional[v1EthSendRawTransactionIntent] = Field(
        default=None
    )
    ethSendTransactionIntent: Optional[v1EthSendTransactionIntent] = Field(default=None)
    createFiatOnRampCredentialIntent: Optional[v1CreateFiatOnRampCredentialIntent] = (
        Field(default=None)
    )
    updateFiatOnRampCredentialIntent: Optional[v1UpdateFiatOnRampCredentialIntent] = (
        Field(default=None)
    )
    deleteFiatOnRampCredentialIntent: Optional[v1DeleteFiatOnRampCredentialIntent] = (
        Field(default=None)
    )
    emailAuthIntentV3: Optional[v1EmailAuthIntentV3] = Field(default=None)
    initUserEmailRecoveryIntentV2: Optional[v1InitUserEmailRecoveryIntentV2] = Field(
        default=None
    )
    initOtpIntentV2: Optional[v1InitOtpIntentV2] = Field(default=None)
    initOtpAuthIntentV3: Optional[v1InitOtpAuthIntentV3] = Field(default=None)
    upsertGasUsageConfigIntent: Optional[v1UpsertGasUsageConfigIntent] = Field(
        default=None
    )


class v1Invitation(TurnkeyBaseModel):
    invitationId: str = Field(
        description="Unique identifier for a given Invitation object."
    )
    receiverUserName: str = Field(
        description="The name of the intended Invitation recipient."
    )
    receiverEmail: str = Field(
        description="The email address of the intended Invitation recipient."
    )
    receiverUserTags: List[str] = Field(
        description="A list of tags assigned to the Invitation recipient."
    )
    accessType: v1AccessType = Field(
        description="The User's permissible access method(s)."
    )
    status: v1InvitationStatus = Field(
        description="The current processing status of a specified Invitation."
    )
    createdAt: externaldatav1Timestamp
    updatedAt: externaldatav1Timestamp
    senderUserId: str = Field(
        description="Unique identifier for the Sender of an Invitation."
    )


class v1InvitationParams(TurnkeyBaseModel):
    receiverUserName: str = Field(
        description="The name of the intended Invitation recipient."
    )
    receiverUserEmail: str = Field(
        description="The email address of the intended Invitation recipient."
    )
    receiverUserTags: List[str] = Field(
        description="A list of tags assigned to the Invitation recipient. This field, if not needed, should be an empty array in your request body."
    )
    accessType: v1AccessType = Field(
        description="The User's permissible access method(s)."
    )
    senderUserId: str = Field(
        description="Unique identifier for the Sender of an Invitation."
    )


class v1InvitationStatus(str, Enum):
    INVITATION_STATUS_CREATED = "INVITATION_STATUS_CREATED"
    INVITATION_STATUS_ACCEPTED = "INVITATION_STATUS_ACCEPTED"
    INVITATION_STATUS_REVOKED = "INVITATION_STATUS_REVOKED"


class v1ListFiatOnRampCredentialsRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )


class v1ListFiatOnRampCredentialsResponse(TurnkeyBaseModel):
    fiatOnRampCredentials: List[v1FiatOnRampCredential]


class v1ListOauth2CredentialsRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )


class v1ListOauth2CredentialsResponse(TurnkeyBaseModel):
    oauth2Credentials: List[v1Oauth2Credential]


class v1ListPrivateKeyTagsRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )


class v1ListPrivateKeyTagsResponse(TurnkeyBaseModel):
    privateKeyTags: List[datav1Tag] = Field(description="A list of private key tags.")


class v1ListUserTagsRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )


class v1ListUserTagsResponse(TurnkeyBaseModel):
    userTags: List[datav1Tag] = Field(description="A list of user tags.")


class v1LoginUsage(TurnkeyBaseModel):
    publicKey: str = Field(description="Public key for authentication")


class v1MnemonicLanguage(str, Enum):
    MNEMONIC_LANGUAGE_ENGLISH = "MNEMONIC_LANGUAGE_ENGLISH"
    MNEMONIC_LANGUAGE_SIMPLIFIED_CHINESE = "MNEMONIC_LANGUAGE_SIMPLIFIED_CHINESE"
    MNEMONIC_LANGUAGE_TRADITIONAL_CHINESE = "MNEMONIC_LANGUAGE_TRADITIONAL_CHINESE"
    MNEMONIC_LANGUAGE_CZECH = "MNEMONIC_LANGUAGE_CZECH"
    MNEMONIC_LANGUAGE_FRENCH = "MNEMONIC_LANGUAGE_FRENCH"
    MNEMONIC_LANGUAGE_ITALIAN = "MNEMONIC_LANGUAGE_ITALIAN"
    MNEMONIC_LANGUAGE_JAPANESE = "MNEMONIC_LANGUAGE_JAPANESE"
    MNEMONIC_LANGUAGE_KOREAN = "MNEMONIC_LANGUAGE_KOREAN"
    MNEMONIC_LANGUAGE_SPANISH = "MNEMONIC_LANGUAGE_SPANISH"


class v1NOOPCodegenAnchorResponse(TurnkeyBaseModel):
    stamp: v1WebAuthnStamp
    tokenUsage: Optional[v1TokenUsage] = Field(default=None)


class v1Oauth2AuthenticateIntent(TurnkeyBaseModel):
    oauth2CredentialId: str = Field(
        description="The OAuth 2.0 credential id whose client_id and client_secret will be used in the OAuth 2.0 flow"
    )
    authCode: str = Field(
        description="The auth_code provided by the OAuth 2.0 provider to the end user to be exchanged for a Bearer token in the OAuth 2.0 flow"
    )
    redirectUri: str = Field(
        description="The URI the user is redirected to after they have authenticated with the OAuth 2.0 provider"
    )
    codeVerifier: str = Field(
        description="The code verifier used by OAuth 2.0 PKCE providers"
    )
    nonce: Optional[str] = Field(
        default=None,
        description="An optional nonce used by the client to prevent replay/substitution of an ID token",
    )
    bearerTokenTargetPublicKey: Optional[str] = Field(
        default=None,
        description="An optional P256 public key to which, if provided, the bearer token will be encrypted and returned via the `encrypted_bearer_token` claim of the OIDC Token",
    )


class v1Oauth2AuthenticateRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1Oauth2AuthenticateIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1Oauth2AuthenticateResult(TurnkeyBaseModel):
    oidcToken: str = Field(
        description="Base64 encoded OIDC token issued by Turnkey to be used with the LoginWithOAuth activity"
    )


class v1Oauth2Credential(TurnkeyBaseModel):
    oauth2CredentialId: str = Field(
        description="Unique identifier for a given OAuth 2.0 Credential."
    )
    organizationId: str = Field(description="Unique identifier for an Organization.")
    provider: v1Oauth2Provider = Field(
        description="The provider for a given OAuth 2.0 Credential."
    )
    clientId: str = Field(description="The client id for a given OAuth 2.0 Credential.")
    encryptedClientSecret: str = Field(
        description="The encrypted client secret for a given OAuth 2.0 Credential encrypted to the TLS Fetcher quorum key."
    )
    createdAt: externaldatav1Timestamp
    updatedAt: externaldatav1Timestamp


class v1Oauth2Provider(str, Enum):
    OAUTH2_PROVIDER_X = "OAUTH2_PROVIDER_X"
    OAUTH2_PROVIDER_DISCORD = "OAUTH2_PROVIDER_DISCORD"


class v1OauthIntent(TurnkeyBaseModel):
    oidcToken: str = Field(description="Base64 encoded OIDC token")
    targetPublicKey: str = Field(
        description="Client-side public key generated by the user, to which the oauth bundle (credentials) will be encrypted."
    )
    apiKeyName: Optional[str] = Field(
        default=None,
        description="Optional human-readable name for an API Key. If none provided, default to Oauth - <Timestamp>",
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.",
    )
    invalidateExisting: Optional[bool] = Field(
        default=None,
        description="Invalidate all other previously generated Oauth API keys",
    )


class v1OauthLoginIntent(TurnkeyBaseModel):
    oidcToken: str = Field(description="Base64 encoded OIDC token")
    publicKey: str = Field(
        description="Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the oidc token associated with this request"
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used.",
    )
    invalidateExisting: Optional[bool] = Field(
        default=None,
        description="Invalidate all other previously generated Login API keys",
    )


class v1OauthLoginRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1OauthLoginIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1OauthLoginResult(TurnkeyBaseModel):
    session: str = Field(
        description="Signed JWT containing an expiry, public key, session type, user id, and organization id"
    )


class v1OauthProvider(TurnkeyBaseModel):
    providerId: str = Field(description="Unique identifier for an OAuth Provider")
    providerName: str = Field(description="Human-readable name to identify a Provider.")
    issuer: str = Field(
        description="The issuer of the token, typically a URL indicating the authentication server, e.g https://accounts.google.com"
    )
    audience: str = Field(
        description="Expected audience ('aud' attribute of the signed token) which represents the app ID"
    )
    subject: str = Field(
        description="Expected subject ('sub' attribute of the signed token) which represents the user ID"
    )
    createdAt: externaldatav1Timestamp
    updatedAt: externaldatav1Timestamp


class v1OauthProviderParams(TurnkeyBaseModel):
    providerName: str = Field(description="Human-readable name to identify a Provider.")
    oidcToken: str = Field(description="Base64 encoded OIDC token")


class v1OauthRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1OauthIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1OauthResult(TurnkeyBaseModel):
    userId: str = Field(description="Unique identifier for the authenticating User.")
    apiKeyId: str = Field(description="Unique identifier for the created API key.")
    credentialBundle: str = Field(description="HPKE encrypted credential bundle")


class v1Operator(str, Enum):
    OPERATOR_EQUAL = "OPERATOR_EQUAL"
    OPERATOR_MORE_THAN = "OPERATOR_MORE_THAN"
    OPERATOR_MORE_THAN_OR_EQUAL = "OPERATOR_MORE_THAN_OR_EQUAL"
    OPERATOR_LESS_THAN = "OPERATOR_LESS_THAN"
    OPERATOR_LESS_THAN_OR_EQUAL = "OPERATOR_LESS_THAN_OR_EQUAL"
    OPERATOR_CONTAINS = "OPERATOR_CONTAINS"
    OPERATOR_NOT_EQUAL = "OPERATOR_NOT_EQUAL"
    OPERATOR_IN = "OPERATOR_IN"
    OPERATOR_NOT_IN = "OPERATOR_NOT_IN"
    OPERATOR_CONTAINS_ONE = "OPERATOR_CONTAINS_ONE"
    OPERATOR_CONTAINS_ALL = "OPERATOR_CONTAINS_ALL"


class v1OrganizationData(TurnkeyBaseModel):
    organizationId: Optional[str] = Field(default=None)
    name: Optional[str] = Field(default=None)
    users: Optional[List[v1User]] = Field(default=None)
    policies: Optional[List[v1Policy]] = Field(default=None)
    privateKeys: Optional[List[v1PrivateKey]] = Field(default=None)
    invitations: Optional[List[v1Invitation]] = Field(default=None)
    tags: Optional[List[datav1Tag]] = Field(default=None)
    rootQuorum: Optional[externaldatav1Quorum] = Field(default=None)
    features: Optional[List[v1Feature]] = Field(default=None)
    wallets: Optional[List[v1Wallet]] = Field(default=None)
    smartContractInterfaceReferences: Optional[
        List[v1SmartContractInterfaceReference]
    ] = Field(default=None)


class v1OtpAuthIntent(TurnkeyBaseModel):
    otpId: str = Field(
        description="ID representing the result of an init OTP activity."
    )
    otpCode: str = Field(description="OTP sent out to a user's contact (email or SMS)")
    targetPublicKey: str = Field(
        description="Client-side public key generated by the user, to which the OTP bundle (credentials) will be encrypted."
    )
    apiKeyName: Optional[str] = Field(
        default=None,
        description="Optional human-readable name for an API Key. If none provided, default to OTP Auth - <Timestamp>",
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.",
    )
    invalidateExisting: Optional[bool] = Field(
        default=None,
        description="Invalidate all other previously generated OTP Auth API keys",
    )


class v1OtpAuthRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1OtpAuthIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1OtpAuthResult(TurnkeyBaseModel):
    userId: str = Field(description="Unique identifier for the authenticating User.")
    apiKeyId: Optional[str] = Field(
        default=None, description="Unique identifier for the created API key."
    )
    credentialBundle: Optional[str] = Field(
        default=None, description="HPKE encrypted credential bundle"
    )


class v1OtpLoginIntent(TurnkeyBaseModel):
    verificationToken: str = Field(
        description="Signed JWT containing a unique id, expiry, verification type, contact"
    )
    publicKey: str = Field(
        description="Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the verification token"
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used.",
    )
    invalidateExisting: Optional[bool] = Field(
        default=None,
        description="Invalidate all other previously generated Login API keys",
    )
    clientSignature: Optional[v1ClientSignature] = Field(
        default=None,
        description="Optional signature proving authorization for this login. The signature is over the verification token ID and the public key. Only required if a public key was provided during the verification step.",
    )


class v1OtpLoginRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1OtpLoginIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1OtpLoginResult(TurnkeyBaseModel):
    session: str = Field(
        description="Signed JWT containing an expiry, public key, session type, user id, and organization id"
    )


class v1Outcome(str, Enum):
    OUTCOME_ALLOW = "OUTCOME_ALLOW"
    OUTCOME_DENY_EXPLICIT = "OUTCOME_DENY_EXPLICIT"
    OUTCOME_DENY_IMPLICIT = "OUTCOME_DENY_IMPLICIT"
    OUTCOME_REQUIRES_CONSENSUS = "OUTCOME_REQUIRES_CONSENSUS"
    OUTCOME_REJECTED = "OUTCOME_REJECTED"
    OUTCOME_ERROR = "OUTCOME_ERROR"


class v1Pagination(TurnkeyBaseModel):
    limit: Optional[str] = Field(
        default=None,
        description="A limit of the number of object to be returned, between 1 and 100. Defaults to 10.",
    )
    before: Optional[str] = Field(
        default=None,
        description="A pagination cursor. This is an object ID that enables you to fetch all objects before this ID.",
    )
    after: Optional[str] = Field(
        default=None,
        description="A pagination cursor. This is an object ID that enables you to fetch all objects after this ID.",
    )


class v1PathFormat(str, Enum):
    PATH_FORMAT_BIP32 = "PATH_FORMAT_BIP32"


class v1PayloadEncoding(str, Enum):
    PAYLOAD_ENCODING_HEXADECIMAL = "PAYLOAD_ENCODING_HEXADECIMAL"
    PAYLOAD_ENCODING_TEXT_UTF8 = "PAYLOAD_ENCODING_TEXT_UTF8"
    PAYLOAD_ENCODING_EIP712 = "PAYLOAD_ENCODING_EIP712"
    PAYLOAD_ENCODING_EIP7702_AUTHORIZATION = "PAYLOAD_ENCODING_EIP7702_AUTHORIZATION"


class v1Policy(TurnkeyBaseModel):
    policyId: str = Field(description="Unique identifier for a given Policy.")
    policyName: str = Field(description="Human-readable name for a Policy.")
    effect: v1Effect = Field(
        description="The instruction to DENY or ALLOW a particular activity following policy selector(s)."
    )
    createdAt: externaldatav1Timestamp
    updatedAt: externaldatav1Timestamp
    notes: str = Field(
        description="Human-readable notes added by a User to describe a particular policy."
    )
    consensus: str = Field(
        description="A consensus expression that evalutes to true or false."
    )
    condition: str = Field(
        description="A condition expression that evalutes to true or false."
    )


class v1PrivateKey(TurnkeyBaseModel):
    privateKeyId: str = Field(description="Unique identifier for a given Private Key.")
    publicKey: str = Field(
        description="The public component of a cryptographic key pair used to sign messages and transactions."
    )
    privateKeyName: str = Field(description="Human-readable name for a Private Key.")
    curve: v1Curve = Field(
        description="Cryptographic Curve used to generate a given Private Key."
    )
    addresses: List[externaldatav1Address] = Field(
        description="Derived cryptocurrency addresses for a given Private Key."
    )
    privateKeyTags: List[str] = Field(description="A list of Private Key Tag IDs.")
    createdAt: externaldatav1Timestamp
    updatedAt: externaldatav1Timestamp
    exported: bool = Field(
        description="True when a given Private Key is exported, false otherwise."
    )
    imported: bool = Field(
        description="True when a given Private Key is imported, false otherwise."
    )


class v1PrivateKeyParams(TurnkeyBaseModel):
    privateKeyName: str = Field(description="Human-readable name for a Private Key.")
    curve: v1Curve = Field(
        description="Cryptographic Curve used to generate a given Private Key."
    )
    privateKeyTags: List[str] = Field(
        description="A list of Private Key Tag IDs. This field, if not needed, should be an empty array in your request body."
    )
    addressFormats: List[v1AddressFormat] = Field(
        description="Cryptocurrency-specific formats for a derived address (e.g., Ethereum)."
    )


class v1PrivateKeyResult(TurnkeyBaseModel):
    privateKeyId: Optional[str] = Field(default=None)
    addresses: Optional[List[immutableactivityv1Address]] = Field(default=None)


class v1PublicKeyCredentialWithAttestation(TurnkeyBaseModel):
    id: str
    type: str
    rawId: str
    authenticatorAttachment: Optional[str] = Field(default=None)
    response: v1AuthenticatorAttestationResponse
    clientExtensionResults: v1SimpleClientExtensionResults


class v1RecoverUserIntent(TurnkeyBaseModel):
    authenticator: v1AuthenticatorParamsV2 = Field(
        description="The new authenticator to register."
    )
    userId: str = Field(
        description="Unique identifier for the user performing recovery."
    )


class v1RecoverUserRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1RecoverUserIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1RecoverUserResult(TurnkeyBaseModel):
    authenticatorId: List[str] = Field(description="ID of the authenticator created.")


class v1RejectActivityIntent(TurnkeyBaseModel):
    fingerprint: str = Field(description="An artifact verifying a User's action.")


class v1RejectActivityRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1RejectActivityIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1RemoveOrganizationFeatureIntent(TurnkeyBaseModel):
    name: v1FeatureName = Field(description="Name of the feature to remove")


class v1RemoveOrganizationFeatureRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1RemoveOrganizationFeatureIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1RemoveOrganizationFeatureResult(TurnkeyBaseModel):
    features: List[v1Feature] = Field(
        description="Resulting list of organization features."
    )


class v1Result(TurnkeyBaseModel):
    createOrganizationResult: Optional[v1CreateOrganizationResult] = Field(default=None)
    createAuthenticatorsResult: Optional[v1CreateAuthenticatorsResult] = Field(
        default=None
    )
    createUsersResult: Optional[v1CreateUsersResult] = Field(default=None)
    createPrivateKeysResult: Optional[v1CreatePrivateKeysResult] = Field(default=None)
    createInvitationsResult: Optional[v1CreateInvitationsResult] = Field(default=None)
    acceptInvitationResult: Optional[v1AcceptInvitationResult] = Field(default=None)
    signRawPayloadResult: Optional[v1SignRawPayloadResult] = Field(default=None)
    createPolicyResult: Optional[v1CreatePolicyResult] = Field(default=None)
    disablePrivateKeyResult: Optional[v1DisablePrivateKeyResult] = Field(default=None)
    deleteUsersResult: Optional[v1DeleteUsersResult] = Field(default=None)
    deleteAuthenticatorsResult: Optional[v1DeleteAuthenticatorsResult] = Field(
        default=None
    )
    deleteInvitationResult: Optional[v1DeleteInvitationResult] = Field(default=None)
    deleteOrganizationResult: Optional[v1DeleteOrganizationResult] = Field(default=None)
    deletePolicyResult: Optional[v1DeletePolicyResult] = Field(default=None)
    createUserTagResult: Optional[v1CreateUserTagResult] = Field(default=None)
    deleteUserTagsResult: Optional[v1DeleteUserTagsResult] = Field(default=None)
    signTransactionResult: Optional[v1SignTransactionResult] = Field(default=None)
    deleteApiKeysResult: Optional[v1DeleteApiKeysResult] = Field(default=None)
    createApiKeysResult: Optional[v1CreateApiKeysResult] = Field(default=None)
    createPrivateKeyTagResult: Optional[v1CreatePrivateKeyTagResult] = Field(
        default=None
    )
    deletePrivateKeyTagsResult: Optional[v1DeletePrivateKeyTagsResult] = Field(
        default=None
    )
    setPaymentMethodResult: Optional[billingSetPaymentMethodResult] = Field(
        default=None
    )
    activateBillingTierResult: Optional[billingActivateBillingTierResult] = Field(
        default=None
    )
    deletePaymentMethodResult: Optional[billingDeletePaymentMethodResult] = Field(
        default=None
    )
    createApiOnlyUsersResult: Optional[v1CreateApiOnlyUsersResult] = Field(default=None)
    updateRootQuorumResult: Optional[v1UpdateRootQuorumResult] = Field(default=None)
    updateUserTagResult: Optional[v1UpdateUserTagResult] = Field(default=None)
    updatePrivateKeyTagResult: Optional[v1UpdatePrivateKeyTagResult] = Field(
        default=None
    )
    createSubOrganizationResult: Optional[v1CreateSubOrganizationResult] = Field(
        default=None
    )
    updateAllowedOriginsResult: Optional[v1UpdateAllowedOriginsResult] = Field(
        default=None
    )
    createPrivateKeysResultV2: Optional[v1CreatePrivateKeysResultV2] = Field(
        default=None
    )
    updateUserResult: Optional[v1UpdateUserResult] = Field(default=None)
    updatePolicyResult: Optional[v1UpdatePolicyResult] = Field(default=None)
    createSubOrganizationResultV3: Optional[v1CreateSubOrganizationResultV3] = Field(
        default=None
    )
    createWalletResult: Optional[v1CreateWalletResult] = Field(default=None)
    createWalletAccountsResult: Optional[v1CreateWalletAccountsResult] = Field(
        default=None
    )
    initUserEmailRecoveryResult: Optional[v1InitUserEmailRecoveryResult] = Field(
        default=None
    )
    recoverUserResult: Optional[v1RecoverUserResult] = Field(default=None)
    setOrganizationFeatureResult: Optional[v1SetOrganizationFeatureResult] = Field(
        default=None
    )
    removeOrganizationFeatureResult: Optional[v1RemoveOrganizationFeatureResult] = (
        Field(default=None)
    )
    exportPrivateKeyResult: Optional[v1ExportPrivateKeyResult] = Field(default=None)
    exportWalletResult: Optional[v1ExportWalletResult] = Field(default=None)
    createSubOrganizationResultV4: Optional[v1CreateSubOrganizationResultV4] = Field(
        default=None
    )
    emailAuthResult: Optional[v1EmailAuthResult] = Field(default=None)
    exportWalletAccountResult: Optional[v1ExportWalletAccountResult] = Field(
        default=None
    )
    initImportWalletResult: Optional[v1InitImportWalletResult] = Field(default=None)
    importWalletResult: Optional[v1ImportWalletResult] = Field(default=None)
    initImportPrivateKeyResult: Optional[v1InitImportPrivateKeyResult] = Field(
        default=None
    )
    importPrivateKeyResult: Optional[v1ImportPrivateKeyResult] = Field(default=None)
    createPoliciesResult: Optional[v1CreatePoliciesResult] = Field(default=None)
    signRawPayloadsResult: Optional[v1SignRawPayloadsResult] = Field(default=None)
    createReadOnlySessionResult: Optional[v1CreateReadOnlySessionResult] = Field(
        default=None
    )
    createOauthProvidersResult: Optional[v1CreateOauthProvidersResult] = Field(
        default=None
    )
    deleteOauthProvidersResult: Optional[v1DeleteOauthProvidersResult] = Field(
        default=None
    )
    createSubOrganizationResultV5: Optional[v1CreateSubOrganizationResultV5] = Field(
        default=None
    )
    oauthResult: Optional[v1OauthResult] = Field(default=None)
    createReadWriteSessionResult: Optional[v1CreateReadWriteSessionResult] = Field(
        default=None
    )
    createSubOrganizationResultV6: Optional[v1CreateSubOrganizationResultV6] = Field(
        default=None
    )
    deletePrivateKeysResult: Optional[v1DeletePrivateKeysResult] = Field(default=None)
    deleteWalletsResult: Optional[v1DeleteWalletsResult] = Field(default=None)
    createReadWriteSessionResultV2: Optional[v1CreateReadWriteSessionResultV2] = Field(
        default=None
    )
    deleteSubOrganizationResult: Optional[v1DeleteSubOrganizationResult] = Field(
        default=None
    )
    initOtpAuthResult: Optional[v1InitOtpAuthResult] = Field(default=None)
    otpAuthResult: Optional[v1OtpAuthResult] = Field(default=None)
    createSubOrganizationResultV7: Optional[v1CreateSubOrganizationResultV7] = Field(
        default=None
    )
    updateWalletResult: Optional[v1UpdateWalletResult] = Field(default=None)
    updatePolicyResultV2: Optional[v1UpdatePolicyResultV2] = Field(default=None)
    initOtpAuthResultV2: Optional[v1InitOtpAuthResultV2] = Field(default=None)
    initOtpResult: Optional[v1InitOtpResult] = Field(default=None)
    verifyOtpResult: Optional[v1VerifyOtpResult] = Field(default=None)
    otpLoginResult: Optional[v1OtpLoginResult] = Field(default=None)
    stampLoginResult: Optional[v1StampLoginResult] = Field(default=None)
    oauthLoginResult: Optional[v1OauthLoginResult] = Field(default=None)
    updateUserNameResult: Optional[v1UpdateUserNameResult] = Field(default=None)
    updateUserEmailResult: Optional[v1UpdateUserEmailResult] = Field(default=None)
    updateUserPhoneNumberResult: Optional[v1UpdateUserPhoneNumberResult] = Field(
        default=None
    )
    initFiatOnRampResult: Optional[v1InitFiatOnRampResult] = Field(default=None)
    createSmartContractInterfaceResult: Optional[
        v1CreateSmartContractInterfaceResult
    ] = Field(default=None)
    deleteSmartContractInterfaceResult: Optional[
        v1DeleteSmartContractInterfaceResult
    ] = Field(default=None)
    enableAuthProxyResult: Optional[v1EnableAuthProxyResult] = Field(default=None)
    disableAuthProxyResult: Optional[v1DisableAuthProxyResult] = Field(default=None)
    updateAuthProxyConfigResult: Optional[v1UpdateAuthProxyConfigResult] = Field(
        default=None
    )
    createOauth2CredentialResult: Optional[v1CreateOauth2CredentialResult] = Field(
        default=None
    )
    updateOauth2CredentialResult: Optional[v1UpdateOauth2CredentialResult] = Field(
        default=None
    )
    deleteOauth2CredentialResult: Optional[v1DeleteOauth2CredentialResult] = Field(
        default=None
    )
    oauth2AuthenticateResult: Optional[v1Oauth2AuthenticateResult] = Field(default=None)
    deleteWalletAccountsResult: Optional[v1DeleteWalletAccountsResult] = Field(
        default=None
    )
    deletePoliciesResult: Optional[v1DeletePoliciesResult] = Field(default=None)
    ethSendRawTransactionResult: Optional[v1EthSendRawTransactionResult] = Field(
        default=None
    )
    createFiatOnRampCredentialResult: Optional[v1CreateFiatOnRampCredentialResult] = (
        Field(default=None)
    )
    updateFiatOnRampCredentialResult: Optional[v1UpdateFiatOnRampCredentialResult] = (
        Field(default=None)
    )
    deleteFiatOnRampCredentialResult: Optional[v1DeleteFiatOnRampCredentialResult] = (
        Field(default=None)
    )
    ethSendTransactionResult: Optional[v1EthSendTransactionResult] = Field(default=None)
    upsertGasUsageConfigResult: Optional[v1UpsertGasUsageConfigResult] = Field(
        default=None
    )


class v1RootUserParams(TurnkeyBaseModel):
    userName: str = Field(description="Human-readable name for a User.")
    userEmail: Optional[str] = Field(
        default=None, description="The user's email address."
    )
    apiKeys: List[apiApiKeyParams] = Field(
        description="A list of API Key parameters. This field, if not needed, should be an empty array in your request body."
    )
    authenticators: List[v1AuthenticatorParamsV2] = Field(
        description="A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body."
    )


class v1RootUserParamsV2(TurnkeyBaseModel):
    userName: str = Field(description="Human-readable name for a User.")
    userEmail: Optional[str] = Field(
        default=None, description="The user's email address."
    )
    apiKeys: List[apiApiKeyParams] = Field(
        description="A list of API Key parameters. This field, if not needed, should be an empty array in your request body."
    )
    authenticators: List[v1AuthenticatorParamsV2] = Field(
        description="A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body."
    )
    oauthProviders: List[v1OauthProviderParams] = Field(
        description="A list of Oauth providers. This field, if not needed, should be an empty array in your request body."
    )


class v1RootUserParamsV3(TurnkeyBaseModel):
    userName: str = Field(description="Human-readable name for a User.")
    userEmail: Optional[str] = Field(
        default=None, description="The user's email address."
    )
    apiKeys: List[v1ApiKeyParamsV2] = Field(
        description="A list of API Key parameters. This field, if not needed, should be an empty array in your request body."
    )
    authenticators: List[v1AuthenticatorParamsV2] = Field(
        description="A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body."
    )
    oauthProviders: List[v1OauthProviderParams] = Field(
        description="A list of Oauth providers. This field, if not needed, should be an empty array in your request body."
    )


class v1RootUserParamsV4(TurnkeyBaseModel):
    userName: str = Field(description="Human-readable name for a User.")
    userEmail: Optional[str] = Field(
        default=None, description="The user's email address."
    )
    userPhoneNumber: Optional[str] = Field(
        default=None,
        description="The user's phone number in E.164 format e.g. +13214567890",
    )
    apiKeys: List[v1ApiKeyParamsV2] = Field(
        description="A list of API Key parameters. This field, if not needed, should be an empty array in your request body."
    )
    authenticators: List[v1AuthenticatorParamsV2] = Field(
        description="A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body."
    )
    oauthProviders: List[v1OauthProviderParams] = Field(
        description="A list of Oauth providers. This field, if not needed, should be an empty array in your request body."
    )


class v1Selector(TurnkeyBaseModel):
    subject: Optional[str] = Field(default=None)
    operator: Optional[v1Operator] = Field(default=None)
    target: Optional[str] = Field(default=None)


class v1SelectorV2(TurnkeyBaseModel):
    subject: Optional[str] = Field(default=None)
    operator: Optional[v1Operator] = Field(default=None)
    targets: Optional[List[str]] = Field(default=None)


class v1SetOrganizationFeatureIntent(TurnkeyBaseModel):
    name: v1FeatureName = Field(description="Name of the feature to set")
    value: str = Field(
        description="Optional value for the feature. Will override existing values if feature is already set."
    )


class v1SetOrganizationFeatureRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1SetOrganizationFeatureIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1SetOrganizationFeatureResult(TurnkeyBaseModel):
    features: List[v1Feature] = Field(
        description="Resulting list of organization features."
    )


class v1SignRawPayloadIntent(TurnkeyBaseModel):
    privateKeyId: str = Field(description="Unique identifier for a given Private Key.")
    payload: str = Field(description="Raw unsigned payload to be signed.")
    encoding: v1PayloadEncoding = Field(
        description="Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8)."
    )
    hashFunction: v1HashFunction = Field(
        description="Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032."
    )


class v1SignRawPayloadIntentV2(TurnkeyBaseModel):
    signWith: str = Field(
        description="A Wallet account address, Private Key address, or Private Key identifier."
    )
    payload: str = Field(description="Raw unsigned payload to be signed.")
    encoding: v1PayloadEncoding = Field(
        description="Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8)."
    )
    hashFunction: v1HashFunction = Field(
        description="Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032."
    )


class v1SignRawPayloadRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1SignRawPayloadIntentV2
    generateAppProofs: Optional[bool] = Field(default=None)


class v1SignRawPayloadResult(TurnkeyBaseModel):
    r: str = Field(description="Component of an ECSDA signature.")
    s: str = Field(description="Component of an ECSDA signature.")
    v: str = Field(description="Component of an ECSDA signature.")


class v1SignRawPayloadsIntent(TurnkeyBaseModel):
    signWith: str = Field(
        description="A Wallet account address, Private Key address, or Private Key identifier."
    )
    payloads: List[str] = Field(
        description="An array of raw unsigned payloads to be signed."
    )
    encoding: v1PayloadEncoding = Field(
        description="Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8)."
    )
    hashFunction: v1HashFunction = Field(
        description="Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032."
    )


class v1SignRawPayloadsRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1SignRawPayloadsIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1SignRawPayloadsResult(TurnkeyBaseModel):
    signatures: Optional[List[v1SignRawPayloadResult]] = Field(default=None)


class v1SignTransactionIntent(TurnkeyBaseModel):
    privateKeyId: str = Field(description="Unique identifier for a given Private Key.")
    unsignedTransaction: str = Field(
        description="Raw unsigned transaction to be signed by a particular Private Key."
    )
    type: v1TransactionType


class v1SignTransactionIntentV2(TurnkeyBaseModel):
    signWith: str = Field(
        description="A Wallet account address, Private Key address, or Private Key identifier."
    )
    unsignedTransaction: str = Field(
        description="Raw unsigned transaction to be signed"
    )
    type: v1TransactionType


class v1SignTransactionRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1SignTransactionIntentV2
    generateAppProofs: Optional[bool] = Field(default=None)


class v1SignTransactionResult(TurnkeyBaseModel):
    signedTransaction: str


class v1SignupUsage(TurnkeyBaseModel):
    email: Optional[str] = Field(default=None)
    phoneNumber: Optional[str] = Field(default=None)
    apiKeys: Optional[List[v1ApiKeyParamsV2]] = Field(default=None)
    authenticators: Optional[List[v1AuthenticatorParamsV2]] = Field(default=None)
    oauthProviders: Optional[List[v1OauthProviderParams]] = Field(default=None)


class v1SimpleClientExtensionResults(TurnkeyBaseModel):
    appid: Optional[bool] = Field(default=None)
    appidExclude: Optional[bool] = Field(default=None)
    credProps: Optional[v1CredPropsAuthenticationExtensionsClientOutputs] = Field(
        default=None
    )


class v1SmartContractInterfaceReference(TurnkeyBaseModel):
    smartContractInterfaceId: Optional[str] = Field(default=None)
    smartContractAddress: Optional[str] = Field(default=None)
    digest: Optional[str] = Field(default=None)


class v1SmartContractInterfaceType(str, Enum):
    SMART_CONTRACT_INTERFACE_TYPE_ETHEREUM = "SMART_CONTRACT_INTERFACE_TYPE_ETHEREUM"
    SMART_CONTRACT_INTERFACE_TYPE_SOLANA = "SMART_CONTRACT_INTERFACE_TYPE_SOLANA"


class v1SmsCustomizationParams(TurnkeyBaseModel):
    template: Optional[str] = Field(
        default=None,
        description="Template containing references to .OtpCode i.e Your OTP is {{.OtpCode}}",
    )


class v1StampLoginIntent(TurnkeyBaseModel):
    publicKey: str = Field(
        description="Client-side public key generated by the user, which will be conditionally added to org data based on the passkey stamp associated with this request"
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used.",
    )
    invalidateExisting: Optional[bool] = Field(
        default=None,
        description="Invalidate all other previously generated Login API keys",
    )


class v1StampLoginRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1StampLoginIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1StampLoginResult(TurnkeyBaseModel):
    session: str = Field(
        description="Signed JWT containing an expiry, public key, session type, user id, and organization id"
    )


class v1TagType(str, Enum):
    TAG_TYPE_USER = "TAG_TYPE_USER"
    TAG_TYPE_PRIVATE_KEY = "TAG_TYPE_PRIVATE_KEY"


class v1TestRateLimitsRequest(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization. If the request is being made by a WebAuthN user and their sub-organization ID is unknown, this can be the parent organization ID; using the sub-organization ID when possible is preferred due to performance reasons."
    )
    isSetLimit: bool = Field(
        description="Whether or not to set a limit on this request."
    )
    limit: int = Field(
        description="Rate limit to set for org, if is_set_limit is set to true."
    )


class v1TestRateLimitsResponse(TurnkeyBaseModel):
    pass


class v1TokenUsage(TurnkeyBaseModel):
    type: v1UsageType = Field(description="Type of token usage")
    tokenId: str = Field(description="Unique identifier for the verification token")
    signup: Optional[v1SignupUsage] = Field(default=None)
    login: Optional[v1LoginUsage] = Field(default=None)


class v1TransactionType(str, Enum):
    TRANSACTION_TYPE_ETHEREUM = "TRANSACTION_TYPE_ETHEREUM"
    TRANSACTION_TYPE_SOLANA = "TRANSACTION_TYPE_SOLANA"
    TRANSACTION_TYPE_TRON = "TRANSACTION_TYPE_TRON"
    TRANSACTION_TYPE_BITCOIN = "TRANSACTION_TYPE_BITCOIN"


class v1UpdateAllowedOriginsIntent(TurnkeyBaseModel):
    allowedOrigins: List[str] = Field(
        description="Additional origins requests are allowed from besides Turnkey origins"
    )


class v1UpdateAllowedOriginsResult(TurnkeyBaseModel):
    pass


class v1UpdateAuthProxyConfigIntent(TurnkeyBaseModel):
    allowedOrigins: Optional[List[str]] = Field(
        default=None, description="Updated list of allowed origins for CORS."
    )
    allowedAuthMethods: Optional[List[str]] = Field(
        default=None,
        description="Updated list of allowed proxy authentication methods.",
    )
    sendFromEmailAddress: Optional[str] = Field(
        default=None, description="Custom 'from' address for auth-related emails."
    )
    replyToEmailAddress: Optional[str] = Field(
        default=None, description="Custom reply-to address for auth-related emails."
    )
    emailAuthTemplateId: Optional[str] = Field(
        default=None, description="Template ID for email-auth messages."
    )
    otpTemplateId: Optional[str] = Field(
        default=None, description="Template ID for OTP SMS messages."
    )
    emailCustomizationParams: Optional[v1EmailCustomizationParams] = Field(
        default=None,
        description="Optional parameters for customizing emails. If not provided, the default email will be used.",
    )
    smsCustomizationParams: Optional[v1SmsCustomizationParams] = Field(
        default=None, description="Overrides for auth-related SMS content."
    )
    walletKitSettings: Optional[v1WalletKitSettingsParams] = Field(
        default=None, description="Overrides for react wallet kit related settings."
    )
    otpExpirationSeconds: Optional[int] = Field(
        default=None, description="OTP code lifetime in seconds."
    )
    verificationTokenExpirationSeconds: Optional[int] = Field(
        default=None, description="Verification-token lifetime in seconds."
    )
    sessionExpirationSeconds: Optional[int] = Field(
        default=None, description="Session lifetime in seconds."
    )
    otpAlphanumeric: Optional[bool] = Field(
        default=None, description="Enable alphanumeric OTP codes."
    )
    otpLength: Optional[int] = Field(
        default=None, description="Desired OTP code length (69)."
    )
    sendFromEmailSenderName: Optional[str] = Field(
        default=None, description="Custom 'from' email sender for auth-related emails."
    )
    verificationTokenRequiredForGetAccountPii: Optional[bool] = Field(
        default=None,
        description="Verification token required for get account with PII (email/phone number). Default false.",
    )


class v1UpdateAuthProxyConfigResult(TurnkeyBaseModel):
    configId: Optional[str] = Field(
        default=None,
        description="Unique identifier for a given User. (representing the turnkey signer user id)",
    )


class v1UpdateFiatOnRampCredentialIntent(TurnkeyBaseModel):
    fiatOnrampCredentialId: str = Field(
        description="The ID of the fiat on-ramp credential to update"
    )
    onrampProvider: v1FiatOnRampProvider = Field(
        description="The fiat on-ramp provider"
    )
    projectId: Optional[str] = Field(
        default=None,
        description="Project ID for the on-ramp provider. Some providers, like Coinbase, require this additional identifier.",
    )
    publishableApiKey: str = Field(
        description="Publishable API key for the on-ramp provider"
    )
    encryptedSecretApiKey: str = Field(
        description="Secret API key for the on-ramp provider encrypted to our on-ramp encryption public key"
    )
    encryptedPrivateApiKey: Optional[str] = Field(
        default=None,
        description="Private API key for the on-ramp provider encrypted to our on-ramp encryption public key. Some providers, like Coinbase, require this additional key.",
    )


class v1UpdateFiatOnRampCredentialRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1UpdateFiatOnRampCredentialIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1UpdateFiatOnRampCredentialResult(TurnkeyBaseModel):
    fiatOnRampCredentialId: str = Field(
        description="Unique identifier of the Fiat On-Ramp credential that was updated"
    )


class v1UpdateOauth2CredentialIntent(TurnkeyBaseModel):
    oauth2CredentialId: str = Field(
        description="The ID of the OAuth 2.0 credential to update"
    )
    provider: v1Oauth2Provider = Field(description="The OAuth 2.0 provider")
    clientId: str = Field(description="The Client ID issued by the OAuth 2.0 provider")
    encryptedClientSecret: str = Field(
        description="The client secret issued by the OAuth 2.0 provider encrypted to the TLS Fetcher quorum key"
    )


class v1UpdateOauth2CredentialRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1UpdateOauth2CredentialIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1UpdateOauth2CredentialResult(TurnkeyBaseModel):
    oauth2CredentialId: str = Field(
        description="Unique identifier of the OAuth 2.0 credential that was updated"
    )


class v1UpdatePolicyIntent(TurnkeyBaseModel):
    policyId: str = Field(description="Unique identifier for a given Policy.")
    policyName: Optional[str] = Field(
        default=None, description="Human-readable name for a Policy."
    )
    policyEffect: Optional[v1Effect] = Field(
        default=None,
        description="The instruction to DENY or ALLOW an activity (optional).",
    )
    policyCondition: Optional[str] = Field(
        default=None,
        description="The condition expression that triggers the Effect (optional).",
    )
    policyConsensus: Optional[str] = Field(
        default=None,
        description="The consensus expression that triggers the Effect (optional).",
    )
    policyNotes: Optional[str] = Field(
        default=None, description="Accompanying notes for a Policy (optional)."
    )


class v1UpdatePolicyIntentV2(TurnkeyBaseModel):
    policyId: str = Field(description="Unique identifier for a given Policy.")
    policyName: Optional[str] = Field(
        default=None, description="Human-readable name for a Policy."
    )
    policyEffect: Optional[v1Effect] = Field(
        default=None,
        description="The instruction to DENY or ALLOW an activity (optional).",
    )
    policyCondition: Optional[str] = Field(
        default=None,
        description="The condition expression that triggers the Effect (optional).",
    )
    policyConsensus: Optional[str] = Field(
        default=None,
        description="The consensus expression that triggers the Effect (optional).",
    )
    policyNotes: Optional[str] = Field(
        default=None, description="Accompanying notes for a Policy (optional)."
    )


class v1UpdatePolicyRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1UpdatePolicyIntentV2
    generateAppProofs: Optional[bool] = Field(default=None)


class v1UpdatePolicyResult(TurnkeyBaseModel):
    policyId: str = Field(description="Unique identifier for a given Policy.")


class v1UpdatePolicyResultV2(TurnkeyBaseModel):
    policyId: str = Field(description="Unique identifier for a given Policy.")


class v1UpdatePrivateKeyTagIntent(TurnkeyBaseModel):
    privateKeyTagId: str = Field(
        description="Unique identifier for a given Private Key Tag."
    )
    newPrivateKeyTagName: Optional[str] = Field(
        default=None,
        description="The new, human-readable name for the tag with the given ID.",
    )
    addPrivateKeyIds: List[str] = Field(
        description="A list of Private Keys IDs to add this tag to."
    )
    removePrivateKeyIds: List[str] = Field(
        description="A list of Private Key IDs to remove this tag from."
    )


class v1UpdatePrivateKeyTagRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1UpdatePrivateKeyTagIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1UpdatePrivateKeyTagResult(TurnkeyBaseModel):
    privateKeyTagId: str = Field(
        description="Unique identifier for a given Private Key Tag."
    )


class v1UpdateRootQuorumIntent(TurnkeyBaseModel):
    threshold: int = Field(
        description="The threshold of unique approvals to reach quorum."
    )
    userIds: List[str] = Field(
        description="The unique identifiers of users who comprise the quorum set."
    )


class v1UpdateRootQuorumRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1UpdateRootQuorumIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1UpdateRootQuorumResult(TurnkeyBaseModel):
    pass


class v1UpdateUserEmailIntent(TurnkeyBaseModel):
    userId: str = Field(description="Unique identifier for a given User.")
    userEmail: str = Field(
        description="The user's email address. Setting this to an empty string will remove the user's email."
    )
    verificationToken: Optional[str] = Field(
        default=None,
        description="Signed JWT containing a unique id, expiry, verification type, contact",
    )


class v1UpdateUserEmailRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1UpdateUserEmailIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1UpdateUserEmailResult(TurnkeyBaseModel):
    userId: str = Field(
        description="Unique identifier of the User whose email was updated."
    )


class v1UpdateUserIntent(TurnkeyBaseModel):
    userId: str = Field(description="Unique identifier for a given User.")
    userName: Optional[str] = Field(
        default=None, description="Human-readable name for a User."
    )
    userEmail: Optional[str] = Field(
        default=None, description="The user's email address."
    )
    userTagIds: Optional[List[str]] = Field(
        default=None,
        description="An updated list of User Tags to apply to this User. This field, if not needed, should be an empty array in your request body.",
    )
    userPhoneNumber: Optional[str] = Field(
        default=None,
        description="The user's phone number in E.164 format e.g. +13214567890",
    )


class v1UpdateUserNameIntent(TurnkeyBaseModel):
    userId: str = Field(description="Unique identifier for a given User.")
    userName: str = Field(description="Human-readable name for a User.")


class v1UpdateUserNameRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1UpdateUserNameIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1UpdateUserNameResult(TurnkeyBaseModel):
    userId: str = Field(
        description="Unique identifier of the User whose name was updated."
    )


class v1UpdateUserPhoneNumberIntent(TurnkeyBaseModel):
    userId: str = Field(description="Unique identifier for a given User.")
    userPhoneNumber: str = Field(
        description="The user's phone number in E.164 format e.g. +13214567890. Setting this to an empty string will remove the user's phone number."
    )
    verificationToken: Optional[str] = Field(
        default=None,
        description="Signed JWT containing a unique id, expiry, verification type, contact",
    )


class v1UpdateUserPhoneNumberRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1UpdateUserPhoneNumberIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1UpdateUserPhoneNumberResult(TurnkeyBaseModel):
    userId: str = Field(
        description="Unique identifier of the User whose phone number was updated."
    )


class v1UpdateUserRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1UpdateUserIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1UpdateUserResult(TurnkeyBaseModel):
    userId: str = Field(description="A User ID.")


class v1UpdateUserTagIntent(TurnkeyBaseModel):
    userTagId: str = Field(description="Unique identifier for a given User Tag.")
    newUserTagName: Optional[str] = Field(
        default=None,
        description="The new, human-readable name for the tag with the given ID.",
    )
    addUserIds: List[str] = Field(description="A list of User IDs to add this tag to.")
    removeUserIds: List[str] = Field(
        description="A list of User IDs to remove this tag from."
    )


class v1UpdateUserTagRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1UpdateUserTagIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1UpdateUserTagResult(TurnkeyBaseModel):
    userTagId: str = Field(description="Unique identifier for a given User Tag.")


class v1UpdateWalletIntent(TurnkeyBaseModel):
    walletId: str = Field(description="Unique identifier for a given Wallet.")
    walletName: Optional[str] = Field(
        default=None, description="Human-readable name for a Wallet."
    )


class v1UpdateWalletRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1UpdateWalletIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1UpdateWalletResult(TurnkeyBaseModel):
    walletId: str = Field(description="A Wallet ID.")


class v1UpsertGasUsageConfigIntent(TurnkeyBaseModel):
    orgWindowLimitUsd: str = Field(
        description="Gas sponsorship USD limit for the billing organization window."
    )
    subOrgWindowLimitUsd: str = Field(
        description="Gas sponsorship USD limit for sub-organizations under the billing organization."
    )
    windowDurationMinutes: str = Field(
        description="Rolling sponsorship window duration, expressed in minutes."
    )


class v1UpsertGasUsageConfigResult(TurnkeyBaseModel):
    gasUsageConfigId: str = Field(
        description="Unique identifier for the gas usage configuration that was created or updated."
    )


class v1UsageType(str, Enum):
    USAGE_TYPE_SIGNUP = "USAGE_TYPE_SIGNUP"
    USAGE_TYPE_LOGIN = "USAGE_TYPE_LOGIN"


class v1User(TurnkeyBaseModel):
    userId: str = Field(description="Unique identifier for a given User.")
    userName: str = Field(description="Human-readable name for a User.")
    userEmail: Optional[str] = Field(
        default=None, description="The user's email address."
    )
    userPhoneNumber: Optional[str] = Field(
        default=None,
        description="The user's phone number in E.164 format e.g. +13214567890",
    )
    authenticators: List[v1Authenticator] = Field(
        description="A list of Authenticator parameters."
    )
    apiKeys: List[v1ApiKey] = Field(
        description="A list of API Key parameters. This field, if not needed, should be an empty array in your request body."
    )
    userTags: List[str] = Field(description="A list of User Tag IDs.")
    oauthProviders: List[v1OauthProvider] = Field(
        description="A list of Oauth Providers."
    )
    createdAt: externaldatav1Timestamp
    updatedAt: externaldatav1Timestamp


class v1UserParams(TurnkeyBaseModel):
    userName: str = Field(description="Human-readable name for a User.")
    userEmail: Optional[str] = Field(
        default=None, description="The user's email address."
    )
    accessType: v1AccessType = Field(
        description="The User's permissible access method(s)."
    )
    apiKeys: List[apiApiKeyParams] = Field(
        description="A list of API Key parameters. This field, if not needed, should be an empty array in your request body."
    )
    authenticators: List[v1AuthenticatorParams] = Field(
        description="A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body."
    )
    userTags: List[str] = Field(
        description="A list of User Tag IDs. This field, if not needed, should be an empty array in your request body."
    )


class v1UserParamsV2(TurnkeyBaseModel):
    userName: str = Field(description="Human-readable name for a User.")
    userEmail: Optional[str] = Field(
        default=None, description="The user's email address."
    )
    apiKeys: List[apiApiKeyParams] = Field(
        description="A list of API Key parameters. This field, if not needed, should be an empty array in your request body."
    )
    authenticators: List[v1AuthenticatorParamsV2] = Field(
        description="A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body."
    )
    userTags: List[str] = Field(
        description="A list of User Tag IDs. This field, if not needed, should be an empty array in your request body."
    )


class v1UserParamsV3(TurnkeyBaseModel):
    userName: str = Field(description="Human-readable name for a User.")
    userEmail: Optional[str] = Field(
        default=None, description="The user's email address."
    )
    userPhoneNumber: Optional[str] = Field(
        default=None,
        description="The user's phone number in E.164 format e.g. +13214567890",
    )
    apiKeys: List[v1ApiKeyParamsV2] = Field(
        description="A list of API Key parameters. This field, if not needed, should be an empty array in your request body."
    )
    authenticators: List[v1AuthenticatorParamsV2] = Field(
        description="A list of Authenticator parameters. This field, if not needed, should be an empty array in your request body."
    )
    oauthProviders: List[v1OauthProviderParams] = Field(
        description="A list of Oauth providers. This field, if not needed, should be an empty array in your request body."
    )
    userTags: List[str] = Field(
        description="A list of User Tag IDs. This field, if not needed, should be an empty array in your request body."
    )


class v1VerifyOtpIntent(TurnkeyBaseModel):
    otpId: str = Field(
        description="ID representing the result of an init OTP activity."
    )
    otpCode: str = Field(description="OTP sent out to a user's contact (email or SMS)")
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the verification token is valid for. If not provided, a default of 1 hour will be used. Maximum value is 86400 seconds (24 hours)",
    )
    publicKey: Optional[str] = Field(
        default=None,
        description="Client-side public key generated by the user, which will be added to the JWT response and verified in subsequent requests via a client proof signature",
    )


class v1VerifyOtpRequest(TurnkeyBaseModel):
    type: str
    timestampMs: str = Field(
        description="Timestamp (in milliseconds) of the request, used to verify liveness of user requests."
    )
    organizationId: str = Field(
        description="Unique identifier for a given Organization."
    )
    parameters: v1VerifyOtpIntent
    generateAppProofs: Optional[bool] = Field(default=None)


class v1VerifyOtpResult(TurnkeyBaseModel):
    verificationToken: str = Field(
        description="Signed JWT containing a unique id, expiry, verification type, contact. Verification status of a user is updated when the token is consumed (in OTP_LOGIN requests)"
    )


class v1Vote(TurnkeyBaseModel):
    id: str = Field(description="Unique identifier for a given Vote object.")
    userId: str = Field(description="Unique identifier for a given User.")
    user: v1User = Field(description="Web and/or API user within your Organization.")
    activityId: str = Field(
        description="Unique identifier for a given Activity object."
    )
    selection: str
    message: str = Field(description="The raw message being signed within a Vote.")
    publicKey: str = Field(
        description="The public component of a cryptographic key pair used to sign messages and transactions."
    )
    signature: str = Field(description="The signature applied to a particular vote.")
    scheme: str = Field(description="Method used to produce a signature.")
    createdAt: externaldatav1Timestamp


class v1Wallet(TurnkeyBaseModel):
    walletId: str = Field(description="Unique identifier for a given Wallet.")
    walletName: str = Field(description="Human-readable name for a Wallet.")
    createdAt: externaldatav1Timestamp
    updatedAt: externaldatav1Timestamp
    exported: bool = Field(
        description="True when a given Wallet is exported, false otherwise."
    )
    imported: bool = Field(
        description="True when a given Wallet is imported, false otherwise."
    )


class v1WalletAccount(TurnkeyBaseModel):
    walletAccountId: str = Field(
        description="Unique identifier for a given Wallet Account."
    )
    organizationId: str = Field(description="The Organization the Account belongs to.")
    walletId: str = Field(description="The Wallet the Account was derived from.")
    curve: v1Curve = Field(
        description="Cryptographic curve used to generate the Account."
    )
    pathFormat: v1PathFormat = Field(
        description="Path format used to generate the Account."
    )
    path: str = Field(description="Path used to generate the Account.")
    addressFormat: v1AddressFormat = Field(
        description="Address format used to generate the Account."
    )
    address: str = Field(
        description="Address generated using the Wallet seed and Account parameters."
    )
    createdAt: externaldatav1Timestamp
    updatedAt: externaldatav1Timestamp
    publicKey: Optional[str] = Field(
        default=None,
        description="The public component of this wallet account's underlying cryptographic key pair.",
    )
    walletDetails: Optional[v1Wallet] = Field(
        default=None,
        description="Wallet details for this account. This is only present when include_wallet_details=true.",
    )


class v1WalletAccountParams(TurnkeyBaseModel):
    curve: v1Curve = Field(
        description="Cryptographic curve used to generate a wallet Account."
    )
    pathFormat: v1PathFormat = Field(
        description="Path format used to generate a wallet Account."
    )
    path: str = Field(description="Path used to generate a wallet Account.")
    addressFormat: v1AddressFormat = Field(
        description="Address format used to generate a wallet Acccount."
    )


class v1WalletKitSettingsParams(TurnkeyBaseModel):
    enabledSocialProviders: Optional[List[str]] = Field(
        default=None,
        description="List of enabled social login providers (e.g., 'apple', 'google', 'facebook')",
    )
    oauthClientIds: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Mapping of social login providers to their Oauth client IDs.",
    )
    oauthRedirectUrl: Optional[str] = Field(
        default=None,
        description="Oauth redirect URL to be used for social login flows.",
    )


class v1WalletParams(TurnkeyBaseModel):
    walletName: str = Field(description="Human-readable name for a Wallet.")
    accounts: List[v1WalletAccountParams] = Field(
        description="A list of wallet Accounts. This field, if not needed, should be an empty array in your request body."
    )
    mnemonicLength: Optional[int] = Field(
        default=None,
        description="Length of mnemonic to generate the Wallet seed. Defaults to 12. Accepted values: 12, 15, 18, 21, 24.",
    )


class v1WalletResult(TurnkeyBaseModel):
    walletId: str
    addresses: List[str] = Field(description="A list of account addresses.")


class v1WebAuthnStamp(TurnkeyBaseModel):
    credentialId: str = Field(
        description="A base64 url encoded Unique identifier for a given credential."
    )
    clientDataJson: str = Field(
        description="A base64 encoded payload containing metadata about the signing context and the challenge."
    )
    authenticatorData: str = Field(
        description="A base64 encoded payload containing metadata about the authenticator."
    )
    signature: str = Field(
        description="The base64 url encoded signature bytes contained within the WebAuthn assertion response."
    )


# --- API Types from Swagger Paths ---


class GetActivityResponse(TurnkeyBaseModel):
    activity: v1Activity = Field(
        description="An action that can be taken within the Turnkey infrastructure."
    )


class GetActivityBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None
    activityId: str = Field(
        description="Unique identifier for a given activity object."
    )


class GetActivityInput(TurnkeyBaseModel):
    body: GetActivityBody


class GetApiKeyResponse(TurnkeyBaseModel):
    apiKey: v1ApiKey = Field(description="An API key.")


class GetApiKeyBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None
    apiKeyId: str = Field(description="Unique identifier for a given API key.")


class GetApiKeyInput(TurnkeyBaseModel):
    body: GetApiKeyBody


class GetApiKeysResponse(TurnkeyBaseModel):
    apiKeys: List[v1ApiKey] = Field(description="A list of API keys.")


class GetApiKeysBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None
    userId: Optional[str] = Field(
        default=None, description="Unique identifier for a given user."
    )


class GetApiKeysInput(TurnkeyBaseModel):
    body: GetApiKeysBody


class GetAttestationDocumentResponse(TurnkeyBaseModel):
    attestationDocument: str = Field(
        description="Raw (CBOR-encoded) attestation document."
    )


class GetAttestationDocumentBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None
    enclaveType: str = Field(
        description="The enclave type, one of: ump, notarizer, signer, evm-parser."
    )


class GetAttestationDocumentInput(TurnkeyBaseModel):
    body: GetAttestationDocumentBody


class GetAuthenticatorResponse(TurnkeyBaseModel):
    authenticator: v1Authenticator = Field(description="An authenticator.")


class GetAuthenticatorBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None
    authenticatorId: str = Field(
        description="Unique identifier for a given authenticator."
    )


class GetAuthenticatorInput(TurnkeyBaseModel):
    body: GetAuthenticatorBody


class GetAuthenticatorsResponse(TurnkeyBaseModel):
    authenticators: List[v1Authenticator] = Field(
        description="A list of authenticators."
    )


class GetAuthenticatorsBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None
    userId: str = Field(description="Unique identifier for a given user.")


class GetAuthenticatorsInput(TurnkeyBaseModel):
    body: GetAuthenticatorsBody


class GetBootProofResponse(TurnkeyBaseModel):
    bootProof: v1BootProof


class GetBootProofBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None
    ephemeralKey: str = Field(description="Hex encoded ephemeral public key.")


class GetBootProofInput(TurnkeyBaseModel):
    body: GetBootProofBody


class GetGasUsageResponse(TurnkeyBaseModel):
    windowDurationMinutes: int = Field(
        description="The window duration (in minutes) for the organization or sub-organization."
    )
    windowLimitUsd: str = Field(
        description="The window limit (in USD) for the organization or sub-organization."
    )
    usageUsd: str = Field(
        description="The total gas usage (in USD) of all sponsored transactions processed over the last `window_duration_minutes`"
    )


class GetGasUsageBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None


class GetGasUsageInput(TurnkeyBaseModel):
    body: GetGasUsageBody


class GetLatestBootProofResponse(TurnkeyBaseModel):
    bootProof: v1BootProof


class GetLatestBootProofBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None
    appName: str = Field(description="Name of enclave app.")


class GetLatestBootProofInput(TurnkeyBaseModel):
    body: GetLatestBootProofBody


class GetNoncesResponse(TurnkeyBaseModel):
    nonce: Optional[str] = Field(
        default=None,
        description="The standard on-chain nonce for the address, if requested.",
    )
    gasStationNonce: Optional[str] = Field(
        default=None,
        description="The gas station nonce for sponsored transactions, if requested.",
    )


class GetNoncesBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None
    address: str = Field(description="The Ethereum address to query nonces for.")
    caip2: str = Field(
        description="The network identifier in CAIP-2 format (e.g., 'eip155:1' for Ethereum mainnet)."
    )
    nonce: Optional[bool] = Field(
        default=None, description="Whether to fetch the standard on-chain nonce."
    )
    gasStationNonce: Optional[bool] = Field(
        default=None,
        description="Whether to fetch the gas station nonce used for sponsored transactions.",
    )


class GetNoncesInput(TurnkeyBaseModel):
    body: GetNoncesBody


class GetOauth2CredentialResponse(TurnkeyBaseModel):
    oauth2Credential: v1Oauth2Credential


class GetOauth2CredentialBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None
    oauth2CredentialId: str = Field(
        description="Unique identifier for a given OAuth 2.0 Credential."
    )


class GetOauth2CredentialInput(TurnkeyBaseModel):
    body: GetOauth2CredentialBody


class GetOauthProvidersResponse(TurnkeyBaseModel):
    oauthProviders: List[v1OauthProvider] = Field(
        description="A list of Oauth providers."
    )


class GetOauthProvidersBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None
    userId: Optional[str] = Field(
        default=None, description="Unique identifier for a given user."
    )


class GetOauthProvidersInput(TurnkeyBaseModel):
    body: GetOauthProvidersBody


class GetOnRampTransactionStatusResponse(TurnkeyBaseModel):
    transactionStatus: str = Field(
        description="The status of the fiat on ramp transaction."
    )


class GetOnRampTransactionStatusBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None
    transactionId: str = Field(
        description="The unique identifier for the fiat on ramp transaction."
    )
    refresh: Optional[bool] = Field(
        default=None,
        description="Optional flag to specify if the transaction status should be refreshed from the fiat on ramp provider. Default = false.",
    )


class GetOnRampTransactionStatusInput(TurnkeyBaseModel):
    body: GetOnRampTransactionStatusBody


class GetOrganizationResponse(TurnkeyBaseModel):
    organizationData: v1OrganizationData = Field(
        description="Object representing the full current and deleted / disabled collection of users, policies, private keys, and invitations attributable to a particular organization."
    )


class GetOrganizationBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None


class GetOrganizationInput(TurnkeyBaseModel):
    body: GetOrganizationBody


class GetOrganizationConfigsResponse(TurnkeyBaseModel):
    configs: v1Config = Field(
        description="Organization configs including quorum settings and organization features."
    )


class GetOrganizationConfigsBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None


class GetOrganizationConfigsInput(TurnkeyBaseModel):
    body: GetOrganizationConfigsBody


class GetPolicyResponse(TurnkeyBaseModel):
    policy: v1Policy = Field(
        description="Object that codifies rules defining the actions that are permissible within an organization."
    )


class GetPolicyBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None
    policyId: str = Field(description="Unique identifier for a given policy.")


class GetPolicyInput(TurnkeyBaseModel):
    body: GetPolicyBody


class GetPolicyEvaluationsResponse(TurnkeyBaseModel):
    policyEvaluations: List[externalactivityv1PolicyEvaluation]


class GetPolicyEvaluationsBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None
    activityId: str = Field(description="Unique identifier for a given activity.")


class GetPolicyEvaluationsInput(TurnkeyBaseModel):
    body: GetPolicyEvaluationsBody


class GetPrivateKeyResponse(TurnkeyBaseModel):
    privateKey: v1PrivateKey = Field(
        description="Cryptographic public/private key pair that can be used for cryptocurrency needs or more generalized encryption."
    )


class GetPrivateKeyBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None
    privateKeyId: str = Field(description="Unique identifier for a given private key.")


class GetPrivateKeyInput(TurnkeyBaseModel):
    body: GetPrivateKeyBody


class GetSendTransactionStatusResponse(TurnkeyBaseModel):
    txStatus: str = Field(description="The current status of the send transaction.")
    eth: Optional[v1EthSendTransactionStatus] = Field(
        default=None, description="Ethereum-specific transaction status."
    )
    txError: Optional[str] = Field(
        default=None,
        description="The error encountered when broadcasting or confirming the transaction, if any.",
    )


class GetSendTransactionStatusBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None
    sendTransactionStatusId: str = Field(
        description="The unique identifier of a send transaction request."
    )


class GetSendTransactionStatusInput(TurnkeyBaseModel):
    body: GetSendTransactionStatusBody


class GetSmartContractInterfaceResponse(TurnkeyBaseModel):
    smartContractInterface: externaldatav1SmartContractInterface = Field(
        description="Object to be used in conjunction with policies to guard transaction signing."
    )


class GetSmartContractInterfaceBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None
    smartContractInterfaceId: str = Field(
        description="Unique identifier for a given smart contract interface."
    )


class GetSmartContractInterfaceInput(TurnkeyBaseModel):
    body: GetSmartContractInterfaceBody


class GetUserResponse(TurnkeyBaseModel):
    user: v1User = Field(description="Web and/or API user within your organization.")


class GetUserBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None
    userId: str = Field(description="Unique identifier for a given user.")


class GetUserInput(TurnkeyBaseModel):
    body: GetUserBody


class GetWalletResponse(TurnkeyBaseModel):
    wallet: v1Wallet = Field(
        description="A collection of deterministically generated cryptographic public / private key pairs that share a common seed."
    )


class GetWalletBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None
    walletId: str = Field(description="Unique identifier for a given wallet.")


class GetWalletInput(TurnkeyBaseModel):
    body: GetWalletBody


class GetWalletAccountResponse(TurnkeyBaseModel):
    account: v1WalletAccount = Field(description="The resulting wallet account.")


class GetWalletAccountBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None
    walletId: str = Field(description="Unique identifier for a given wallet.")
    address: Optional[str] = Field(
        default=None, description="Address corresponding to a wallet account."
    )
    path: Optional[str] = Field(
        default=None, description="Path corresponding to a wallet account."
    )


class GetWalletAccountInput(TurnkeyBaseModel):
    body: GetWalletAccountBody


class GetActivitiesResponse(TurnkeyBaseModel):
    activities: List[v1Activity] = Field(description="A list of activities.")


class GetActivitiesBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None
    filterByStatus: Optional[List[v1ActivityStatus]] = Field(
        default=None,
        description="Array of activity statuses filtering which activities will be listed in the response.",
    )
    paginationOptions: Optional[v1Pagination] = Field(
        default=None, description="Parameters used for cursor-based pagination."
    )
    filterByType: Optional[List[v1ActivityType]] = Field(
        default=None,
        description="Array of activity types filtering which activities will be listed in the response.",
    )


class GetActivitiesInput(TurnkeyBaseModel):
    body: GetActivitiesBody


class GetAppProofsResponse(TurnkeyBaseModel):
    appProofs: List[v1AppProof]


class GetAppProofsBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None
    activityId: str = Field(description="Unique identifier for a given activity.")


class GetAppProofsInput(TurnkeyBaseModel):
    body: GetAppProofsBody


class ListFiatOnRampCredentialsResponse(TurnkeyBaseModel):
    fiatOnRampCredentials: List[v1FiatOnRampCredential]


class ListFiatOnRampCredentialsBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None


class ListFiatOnRampCredentialsInput(TurnkeyBaseModel):
    body: ListFiatOnRampCredentialsBody


class ListOauth2CredentialsResponse(TurnkeyBaseModel):
    oauth2Credentials: List[v1Oauth2Credential]


class ListOauth2CredentialsBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None


class ListOauth2CredentialsInput(TurnkeyBaseModel):
    body: ListOauth2CredentialsBody


class GetPoliciesResponse(TurnkeyBaseModel):
    policies: List[v1Policy] = Field(description="A list of policies.")


class GetPoliciesBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None


class GetPoliciesInput(TurnkeyBaseModel):
    body: GetPoliciesBody


class ListPrivateKeyTagsResponse(TurnkeyBaseModel):
    privateKeyTags: List[datav1Tag] = Field(description="A list of private key tags.")


class ListPrivateKeyTagsBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None


class ListPrivateKeyTagsInput(TurnkeyBaseModel):
    body: ListPrivateKeyTagsBody


class GetPrivateKeysResponse(TurnkeyBaseModel):
    privateKeys: List[v1PrivateKey] = Field(description="A list of private keys.")


class GetPrivateKeysBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None


class GetPrivateKeysInput(TurnkeyBaseModel):
    body: GetPrivateKeysBody


class GetSmartContractInterfacesResponse(TurnkeyBaseModel):
    smartContractInterfaces: List[externaldatav1SmartContractInterface] = Field(
        description="A list of smart contract interfaces."
    )


class GetSmartContractInterfacesBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None


class GetSmartContractInterfacesInput(TurnkeyBaseModel):
    body: GetSmartContractInterfacesBody


class GetSubOrgIdsResponse(TurnkeyBaseModel):
    organizationIds: List[str] = Field(
        description="List of unique identifiers for the matching sub-organizations."
    )


class GetSubOrgIdsBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None
    filterType: Optional[str] = Field(
        default=None,
        description="Specifies the type of filter to apply, i.e 'CREDENTIAL_ID', 'NAME', 'USERNAME', 'EMAIL', 'PHONE_NUMBER', 'OIDC_TOKEN', 'WALLET_ACCOUNT_ADDRESS' or 'PUBLIC_KEY'",
    )
    filterValue: Optional[str] = Field(
        default=None,
        description="The value of the filter to apply for the specified type. For example, a specific email or name string.",
    )
    paginationOptions: Optional[v1Pagination] = Field(
        default=None, description="Parameters used for cursor-based pagination."
    )


class GetSubOrgIdsInput(TurnkeyBaseModel):
    body: GetSubOrgIdsBody


class ListUserTagsResponse(TurnkeyBaseModel):
    userTags: List[datav1Tag] = Field(description="A list of user tags.")


class ListUserTagsBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None


class ListUserTagsInput(TurnkeyBaseModel):
    body: ListUserTagsBody


class GetUsersResponse(TurnkeyBaseModel):
    users: List[v1User] = Field(description="A list of users.")


class GetUsersBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None


class GetUsersInput(TurnkeyBaseModel):
    body: GetUsersBody


class GetVerifiedSubOrgIdsResponse(TurnkeyBaseModel):
    organizationIds: List[str] = Field(
        description="List of unique identifiers for the matching sub-organizations."
    )


class GetVerifiedSubOrgIdsBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None
    filterType: Optional[str] = Field(
        default=None,
        description="Specifies the type of filter to apply, i.e 'EMAIL', 'PHONE_NUMBER'.",
    )
    filterValue: Optional[str] = Field(
        default=None,
        description="The value of the filter to apply for the specified type. For example, a specific email or phone number string.",
    )
    paginationOptions: Optional[v1Pagination] = Field(
        default=None, description="Parameters used for cursor-based pagination."
    )


class GetVerifiedSubOrgIdsInput(TurnkeyBaseModel):
    body: GetVerifiedSubOrgIdsBody


class GetWalletAccountsResponse(TurnkeyBaseModel):
    accounts: List[v1WalletAccount] = Field(
        description="A list of accounts generated from a wallet that share a common seed."
    )


class GetWalletAccountsBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None
    walletId: Optional[str] = Field(
        default=None,
        description="Unique identifier for a given wallet. If not provided, all accounts for the organization will be returned.",
    )
    includeWalletDetails: Optional[bool] = Field(
        default=None,
        description="Optional flag to specify if the wallet details should be included in the response. Default = false.",
    )
    paginationOptions: Optional[v1Pagination] = Field(
        default=None, description="Parameters used for cursor-based pagination."
    )


class GetWalletAccountsInput(TurnkeyBaseModel):
    body: GetWalletAccountsBody


class GetWalletsResponse(TurnkeyBaseModel):
    wallets: List[v1Wallet] = Field(description="A list of wallets.")


class GetWalletsBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None


class GetWalletsInput(TurnkeyBaseModel):
    body: GetWalletsBody


class GetWhoamiResponse(TurnkeyBaseModel):
    organizationId: str = Field(
        description="Unique identifier for a given organization."
    )
    organizationName: str = Field(
        description="Human-readable name for an organization."
    )
    userId: str = Field(description="Unique identifier for a given user.")
    username: str = Field(description="Human-readable name for a user.")


class GetWhoamiBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None


class GetWhoamiInput(TurnkeyBaseModel):
    body: GetWhoamiBody


class ApproveActivityResponse(TurnkeyBaseModel):
    activity: v1Activity = Field(
        description="An action that can be taken within the Turnkey infrastructure."
    )


class ApproveActivityBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    fingerprint: str = Field(description="An artifact verifying a User's action.")


class ApproveActivityInput(TurnkeyBaseModel):
    body: ApproveActivityBody


class CreateApiKeysResponse(TurnkeyBaseModel):
    activity: v1Activity
    apiKeyIds: List[str] = Field(description="A list of API Key IDs.")


class CreateApiKeysBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    apiKeys: List[v1ApiKeyParamsV2] = Field(description="A list of API Keys.")
    userId: str = Field(description="Unique identifier for a given User.")


class CreateApiKeysInput(TurnkeyBaseModel):
    body: CreateApiKeysBody


class CreateApiOnlyUsersResponse(TurnkeyBaseModel):
    activity: v1Activity
    userIds: List[str] = Field(description="A list of API-only User IDs.")


class CreateApiOnlyUsersBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    apiOnlyUsers: List[v1ApiOnlyUserParams] = Field(
        description="A list of API-only Users to create."
    )


class CreateApiOnlyUsersInput(TurnkeyBaseModel):
    body: CreateApiOnlyUsersBody


class CreateAuthenticatorsResponse(TurnkeyBaseModel):
    activity: v1Activity
    authenticatorIds: List[str] = Field(description="A list of Authenticator IDs.")


class CreateAuthenticatorsBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    authenticators: List[v1AuthenticatorParamsV2] = Field(
        description="A list of Authenticators."
    )
    userId: str = Field(description="Unique identifier for a given User.")


class CreateAuthenticatorsInput(TurnkeyBaseModel):
    body: CreateAuthenticatorsBody


class CreateFiatOnRampCredentialResponse(TurnkeyBaseModel):
    activity: v1Activity
    fiatOnRampCredentialId: str = Field(
        description="Unique identifier of the Fiat On-Ramp credential that was created"
    )


class CreateFiatOnRampCredentialBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    onrampProvider: v1FiatOnRampProvider = Field(
        description="The fiat on-ramp provider"
    )
    projectId: Optional[str] = Field(
        default=None,
        description="Project ID for the on-ramp provider. Some providers, like Coinbase, require this additional identifier",
    )
    publishableApiKey: str = Field(
        description="Publishable API key for the on-ramp provider"
    )
    encryptedSecretApiKey: str = Field(
        description="Secret API key for the on-ramp provider encrypted to our on-ramp encryption public key"
    )
    encryptedPrivateApiKey: Optional[str] = Field(
        default=None,
        description="Private API key for the on-ramp provider encrypted to our on-ramp encryption public key. Some providers, like Coinbase, require this additional key.",
    )
    sandboxMode: Optional[bool] = Field(
        default=None, description="If the on-ramp credential is a sandbox credential"
    )


class CreateFiatOnRampCredentialInput(TurnkeyBaseModel):
    body: CreateFiatOnRampCredentialBody


class CreateInvitationsResponse(TurnkeyBaseModel):
    activity: v1Activity
    invitationIds: List[str] = Field(description="A list of Invitation IDs")


class CreateInvitationsBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    invitations: List[v1InvitationParams] = Field(description="A list of Invitations.")


class CreateInvitationsInput(TurnkeyBaseModel):
    body: CreateInvitationsBody


class CreateOauth2CredentialResponse(TurnkeyBaseModel):
    activity: v1Activity
    oauth2CredentialId: str = Field(
        description="Unique identifier of the OAuth 2.0 credential that was created"
    )


class CreateOauth2CredentialBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    provider: v1Oauth2Provider = Field(description="The OAuth 2.0 provider")
    clientId: str = Field(description="The Client ID issued by the OAuth 2.0 provider")
    encryptedClientSecret: str = Field(
        description="The client secret issued by the OAuth 2.0 provider encrypted to the TLS Fetcher quorum key"
    )


class CreateOauth2CredentialInput(TurnkeyBaseModel):
    body: CreateOauth2CredentialBody


class CreateOauthProvidersResponse(TurnkeyBaseModel):
    activity: v1Activity
    providerIds: List[str] = Field(
        description="A list of unique identifiers for Oauth Providers"
    )


class CreateOauthProvidersBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    userId: str = Field(description="The ID of the User to add an Oauth provider to")
    oauthProviders: List[v1OauthProviderParams] = Field(
        description="A list of Oauth providers."
    )


class CreateOauthProvidersInput(TurnkeyBaseModel):
    body: CreateOauthProvidersBody


class CreatePoliciesResponse(TurnkeyBaseModel):
    activity: v1Activity
    policyIds: List[str] = Field(
        description="A list of unique identifiers for the created policies."
    )


class CreatePoliciesBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    policies: List[v1CreatePolicyIntentV3] = Field(
        description="An array of policy intents to be created."
    )


class CreatePoliciesInput(TurnkeyBaseModel):
    body: CreatePoliciesBody


class CreatePolicyResponse(TurnkeyBaseModel):
    activity: v1Activity
    policyId: str = Field(description="Unique identifier for a given Policy.")


class CreatePolicyBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    policyName: str = Field(description="Human-readable name for a Policy.")
    effect: v1Effect = Field(
        description="The instruction to DENY or ALLOW an activity."
    )
    condition: Optional[str] = Field(
        default=None, description="The condition expression that triggers the Effect"
    )
    consensus: Optional[str] = Field(
        default=None, description="The consensus expression that triggers the Effect"
    )
    notes: str = Field(description="Notes for a Policy.")


class CreatePolicyInput(TurnkeyBaseModel):
    body: CreatePolicyBody


class CreatePrivateKeyTagResponse(TurnkeyBaseModel):
    activity: v1Activity
    privateKeyTagId: str = Field(
        description="Unique identifier for a given Private Key Tag."
    )
    privateKeyIds: List[str] = Field(description="A list of Private Key IDs.")


class CreatePrivateKeyTagBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    privateKeyTagName: str = Field(
        description="Human-readable name for a Private Key Tag."
    )
    privateKeyIds: List[str] = Field(description="A list of Private Key IDs.")


class CreatePrivateKeyTagInput(TurnkeyBaseModel):
    body: CreatePrivateKeyTagBody


class CreatePrivateKeysResponse(TurnkeyBaseModel):
    activity: v1Activity
    privateKeys: List[v1PrivateKeyResult] = Field(
        description="A list of Private Key IDs and addresses."
    )


class CreatePrivateKeysBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    privateKeys: List[v1PrivateKeyParams] = Field(description="A list of Private Keys.")


class CreatePrivateKeysInput(TurnkeyBaseModel):
    body: CreatePrivateKeysBody


class CreateReadOnlySessionResponse(TurnkeyBaseModel):
    activity: v1Activity
    organizationId: str = Field(
        description="Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons."
    )
    organizationName: str = Field(
        description="Human-readable name for an Organization."
    )
    userId: str = Field(description="Unique identifier for a given User.")
    username: str = Field(description="Human-readable name for a User.")
    session: str = Field(description="String representing a read only session")
    sessionExpiry: str = Field(
        description="UTC timestamp in seconds representing the expiry time for the read only session."
    )


class CreateReadOnlySessionBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None


class CreateReadOnlySessionInput(TurnkeyBaseModel):
    body: CreateReadOnlySessionBody


class CreateReadWriteSessionResponse(TurnkeyBaseModel):
    activity: v1Activity
    organizationId: str = Field(
        description="Unique identifier for a given Organization. If the request is being made by a user and their Sub-Organization ID is unknown, this can be the Parent Organization ID. However, using the Sub-Organization ID is preferred due to performance reasons."
    )
    organizationName: str = Field(
        description="Human-readable name for an Organization."
    )
    userId: str = Field(description="Unique identifier for a given User.")
    username: str = Field(description="Human-readable name for a User.")
    apiKeyId: str = Field(description="Unique identifier for the created API key.")
    credentialBundle: str = Field(description="HPKE encrypted credential bundle")


class CreateReadWriteSessionBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    targetPublicKey: str = Field(
        description="Client-side public key generated by the user, to which the read write session bundle (credentials) will be encrypted."
    )
    userId: Optional[str] = Field(
        default=None, description="Unique identifier for a given User."
    )
    apiKeyName: Optional[str] = Field(
        default=None,
        description="Optional human-readable name for an API Key. If none provided, default to Read Write Session - <Timestamp>",
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.",
    )
    invalidateExisting: Optional[bool] = Field(
        default=None,
        description="Invalidate all other previously generated ReadWriteSession API keys",
    )


class CreateReadWriteSessionInput(TurnkeyBaseModel):
    body: CreateReadWriteSessionBody


class CreateSmartContractInterfaceResponse(TurnkeyBaseModel):
    activity: v1Activity
    smartContractInterfaceId: str = Field(
        description="The ID of the created Smart Contract Interface."
    )


class CreateSmartContractInterfaceBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    smartContractAddress: str = Field(
        description="Corresponding contract address or program ID"
    )
    smartContractInterface: str = Field(
        description="ABI/IDL as a JSON string. Limited to 400kb"
    )
    type: v1SmartContractInterfaceType
    label: str = Field(
        description="Human-readable name for a Smart Contract Interface."
    )
    notes: Optional[str] = Field(
        default=None, description="Notes for a Smart Contract Interface."
    )


class CreateSmartContractInterfaceInput(TurnkeyBaseModel):
    body: CreateSmartContractInterfaceBody


class CreateSubOrganizationResponse(TurnkeyBaseModel):
    activity: v1Activity
    subOrganizationId: str
    wallet: Optional[v1WalletResult] = Field(default=None)
    rootUserIds: Optional[List[str]] = Field(default=None)


class CreateSubOrganizationBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    subOrganizationName: str = Field(description="Name for this sub-organization")
    rootUsers: List[v1RootUserParamsV4] = Field(
        description="Root users to create within this sub-organization"
    )
    rootQuorumThreshold: int = Field(
        description="The threshold of unique approvals to reach root quorum. This value must be less than or equal to the number of root users"
    )
    wallet: Optional[v1WalletParams] = Field(
        default=None, description="The wallet to create for the sub-organization"
    )
    disableEmailRecovery: Optional[bool] = Field(
        default=None, description="Disable email recovery for the sub-organization"
    )
    disableEmailAuth: Optional[bool] = Field(
        default=None, description="Disable email auth for the sub-organization"
    )
    disableSmsAuth: Optional[bool] = Field(
        default=None, description="Disable OTP SMS auth for the sub-organization"
    )
    disableOtpEmailAuth: Optional[bool] = Field(
        default=None, description="Disable OTP email auth for the sub-organization"
    )
    verificationToken: Optional[str] = Field(
        default=None,
        description="Signed JWT containing a unique id, expiry, verification type, contact",
    )
    clientSignature: Optional[v1ClientSignature] = Field(
        default=None,
        description="Optional signature proving authorization for this sub-organization creation. The signature is over the verification token ID and the root user parameters for the root user associated with the verification token. Only required if a public key was provided during the verification step.",
    )


class CreateSubOrganizationInput(TurnkeyBaseModel):
    body: CreateSubOrganizationBody


class CreateUserTagResponse(TurnkeyBaseModel):
    activity: v1Activity
    userTagId: str = Field(description="Unique identifier for a given User Tag.")
    userIds: List[str] = Field(description="A list of User IDs.")


class CreateUserTagBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    userTagName: str = Field(description="Human-readable name for a User Tag.")
    userIds: List[str] = Field(description="A list of User IDs.")


class CreateUserTagInput(TurnkeyBaseModel):
    body: CreateUserTagBody


class CreateUsersResponse(TurnkeyBaseModel):
    activity: v1Activity
    userIds: List[str] = Field(description="A list of User IDs.")


class CreateUsersBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    users: List[v1UserParamsV3] = Field(description="A list of Users.")


class CreateUsersInput(TurnkeyBaseModel):
    body: CreateUsersBody


class CreateWalletResponse(TurnkeyBaseModel):
    activity: v1Activity
    walletId: str = Field(description="Unique identifier for a Wallet.")
    addresses: List[str] = Field(description="A list of account addresses.")


class CreateWalletBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    walletName: str = Field(description="Human-readable name for a Wallet.")
    accounts: List[v1WalletAccountParams] = Field(
        description="A list of wallet Accounts. This field, if not needed, should be an empty array in your request body."
    )
    mnemonicLength: Optional[int] = Field(
        default=None,
        description="Length of mnemonic to generate the Wallet seed. Defaults to 12. Accepted values: 12, 15, 18, 21, 24.",
    )


class CreateWalletInput(TurnkeyBaseModel):
    body: CreateWalletBody


class CreateWalletAccountsResponse(TurnkeyBaseModel):
    activity: v1Activity
    addresses: List[str] = Field(description="A list of derived addresses.")


class CreateWalletAccountsBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    walletId: str = Field(description="Unique identifier for a given Wallet.")
    accounts: List[v1WalletAccountParams] = Field(
        description="A list of wallet Accounts."
    )
    persist: Optional[bool] = Field(
        default=None,
        description="Indicates if the wallet accounts should be persisted. This is helpful if you'd like to see the addresses of different derivation paths without actually creating the accounts. Defaults to true.",
    )


class CreateWalletAccountsInput(TurnkeyBaseModel):
    body: CreateWalletAccountsBody


class DeleteApiKeysResponse(TurnkeyBaseModel):
    activity: v1Activity
    apiKeyIds: List[str] = Field(description="A list of API Key IDs.")


class DeleteApiKeysBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    userId: str = Field(description="Unique identifier for a given User.")
    apiKeyIds: List[str] = Field(description="A list of API Key IDs.")


class DeleteApiKeysInput(TurnkeyBaseModel):
    body: DeleteApiKeysBody


class DeleteAuthenticatorsResponse(TurnkeyBaseModel):
    activity: v1Activity
    authenticatorIds: List[str] = Field(
        description="Unique identifier for a given Authenticator."
    )


class DeleteAuthenticatorsBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    userId: str = Field(description="Unique identifier for a given User.")
    authenticatorIds: List[str] = Field(description="A list of Authenticator IDs.")


class DeleteAuthenticatorsInput(TurnkeyBaseModel):
    body: DeleteAuthenticatorsBody


class DeleteFiatOnRampCredentialResponse(TurnkeyBaseModel):
    activity: v1Activity
    fiatOnRampCredentialId: str = Field(
        description="Unique identifier of the Fiat On-Ramp credential that was deleted"
    )


class DeleteFiatOnRampCredentialBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    fiatOnrampCredentialId: str = Field(
        description="The ID of the fiat on-ramp credential to delete"
    )


class DeleteFiatOnRampCredentialInput(TurnkeyBaseModel):
    body: DeleteFiatOnRampCredentialBody


class DeleteInvitationResponse(TurnkeyBaseModel):
    activity: v1Activity
    invitationId: str = Field(description="Unique identifier for a given Invitation.")


class DeleteInvitationBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    invitationId: str = Field(
        description="Unique identifier for a given Invitation object."
    )


class DeleteInvitationInput(TurnkeyBaseModel):
    body: DeleteInvitationBody


class DeleteOauth2CredentialResponse(TurnkeyBaseModel):
    activity: v1Activity
    oauth2CredentialId: str = Field(
        description="Unique identifier of the OAuth 2.0 credential that was deleted"
    )


class DeleteOauth2CredentialBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    oauth2CredentialId: str = Field(
        description="The ID of the OAuth 2.0 credential to delete"
    )


class DeleteOauth2CredentialInput(TurnkeyBaseModel):
    body: DeleteOauth2CredentialBody


class DeleteOauthProvidersResponse(TurnkeyBaseModel):
    activity: v1Activity
    providerIds: List[str] = Field(
        description="A list of unique identifiers for Oauth Providers"
    )


class DeleteOauthProvidersBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    userId: str = Field(
        description="The ID of the User to remove an Oauth provider from"
    )
    providerIds: List[str] = Field(
        description="Unique identifier for a given Provider."
    )


class DeleteOauthProvidersInput(TurnkeyBaseModel):
    body: DeleteOauthProvidersBody


class DeletePoliciesResponse(TurnkeyBaseModel):
    activity: v1Activity
    policyIds: List[str] = Field(
        description="A list of unique identifiers for the deleted policies."
    )


class DeletePoliciesBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    policyIds: List[str] = Field(
        description="List of unique identifiers for policies within an organization"
    )


class DeletePoliciesInput(TurnkeyBaseModel):
    body: DeletePoliciesBody


class DeletePolicyResponse(TurnkeyBaseModel):
    activity: v1Activity
    policyId: str = Field(description="Unique identifier for a given Policy.")


class DeletePolicyBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    policyId: str = Field(description="Unique identifier for a given Policy.")


class DeletePolicyInput(TurnkeyBaseModel):
    body: DeletePolicyBody


class DeletePrivateKeyTagsResponse(TurnkeyBaseModel):
    activity: v1Activity
    privateKeyTagIds: List[str] = Field(description="A list of Private Key Tag IDs.")
    privateKeyIds: List[str] = Field(description="A list of Private Key IDs.")


class DeletePrivateKeyTagsBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    privateKeyTagIds: List[str] = Field(description="A list of Private Key Tag IDs.")


class DeletePrivateKeyTagsInput(TurnkeyBaseModel):
    body: DeletePrivateKeyTagsBody


class DeletePrivateKeysResponse(TurnkeyBaseModel):
    activity: v1Activity
    privateKeyIds: List[str] = Field(
        description="A list of private key unique identifiers that were removed"
    )


class DeletePrivateKeysBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    privateKeyIds: List[str] = Field(
        description="List of unique identifiers for private keys within an organization"
    )
    deleteWithoutExport: Optional[bool] = Field(
        default=None,
        description="Optional parameter for deleting the private keys, even if any have not been previously exported. If they have been exported, this field is ignored.",
    )


class DeletePrivateKeysInput(TurnkeyBaseModel):
    body: DeletePrivateKeysBody


class DeleteSmartContractInterfaceResponse(TurnkeyBaseModel):
    activity: v1Activity
    smartContractInterfaceId: str = Field(
        description="The ID of the deleted Smart Contract Interface."
    )


class DeleteSmartContractInterfaceBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    smartContractInterfaceId: str = Field(
        description="The ID of a Smart Contract Interface intended for deletion."
    )


class DeleteSmartContractInterfaceInput(TurnkeyBaseModel):
    body: DeleteSmartContractInterfaceBody


class DeleteSubOrganizationResponse(TurnkeyBaseModel):
    activity: v1Activity
    subOrganizationUuid: str = Field(
        description="Unique identifier of the sub organization that was removed"
    )


class DeleteSubOrganizationBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    deleteWithoutExport: Optional[bool] = Field(
        default=None,
        description="Sub-organization deletion, by default, requires associated wallets and private keys to be exported for security reasons. Set this boolean to true to force sub-organization deletion even if some wallets or private keys within it have not been exported yet. Default: false.",
    )


class DeleteSubOrganizationInput(TurnkeyBaseModel):
    body: DeleteSubOrganizationBody


class DeleteUserTagsResponse(TurnkeyBaseModel):
    activity: v1Activity
    userTagIds: List[str] = Field(description="A list of User Tag IDs.")
    userIds: List[str] = Field(description="A list of User IDs.")


class DeleteUserTagsBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    userTagIds: List[str] = Field(description="A list of User Tag IDs.")


class DeleteUserTagsInput(TurnkeyBaseModel):
    body: DeleteUserTagsBody


class DeleteUsersResponse(TurnkeyBaseModel):
    activity: v1Activity
    userIds: List[str] = Field(description="A list of User IDs.")


class DeleteUsersBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    userIds: List[str] = Field(description="A list of User IDs.")


class DeleteUsersInput(TurnkeyBaseModel):
    body: DeleteUsersBody


class DeleteWalletAccountsResponse(TurnkeyBaseModel):
    activity: v1Activity
    walletAccountIds: List[str] = Field(
        description="A list of wallet account unique identifiers that were removed"
    )


class DeleteWalletAccountsBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    walletAccountIds: List[str] = Field(
        description="List of unique identifiers for wallet accounts within an organization"
    )
    deleteWithoutExport: Optional[bool] = Field(
        default=None,
        description="Optional parameter for deleting the wallet accounts, even if any have not been previously exported. If they have been exported, this field is ignored.",
    )


class DeleteWalletAccountsInput(TurnkeyBaseModel):
    body: DeleteWalletAccountsBody


class DeleteWalletsResponse(TurnkeyBaseModel):
    activity: v1Activity
    walletIds: List[str] = Field(
        description="A list of wallet unique identifiers that were removed"
    )


class DeleteWalletsBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    walletIds: List[str] = Field(
        description="List of unique identifiers for wallets within an organization"
    )
    deleteWithoutExport: Optional[bool] = Field(
        default=None,
        description="Optional parameter for deleting the wallets, even if any have not been previously exported. If they have been exported, this field is ignored.",
    )


class DeleteWalletsInput(TurnkeyBaseModel):
    body: DeleteWalletsBody


class EmailAuthResponse(TurnkeyBaseModel):
    activity: v1Activity
    userId: str = Field(description="Unique identifier for the authenticating User.")
    apiKeyId: str = Field(description="Unique identifier for the created API key.")


class EmailAuthBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    email: str = Field(description="Email of the authenticating user.")
    targetPublicKey: str = Field(
        description="Client-side public key generated by the user, to which the email auth bundle (credentials) will be encrypted."
    )
    apiKeyName: Optional[str] = Field(
        default=None,
        description="Optional human-readable name for an API Key. If none provided, default to Email Auth - <Timestamp>",
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.",
    )
    emailCustomization: v1EmailAuthCustomizationParams = Field(
        description="Parameters for customizing emails. If not provided, the default email will be used. Note that app_name is required."
    )
    invalidateExisting: Optional[bool] = Field(
        default=None,
        description="Invalidate all other previously generated Email Auth API keys",
    )
    sendFromEmailAddress: Optional[str] = Field(
        default=None,
        description="Optional custom email address from which to send the email",
    )
    sendFromEmailSenderName: Optional[str] = Field(
        default=None,
        description="Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'",
    )
    replyToEmailAddress: Optional[str] = Field(
        default=None, description="Optional custom email address to use as reply-to"
    )


class EmailAuthInput(TurnkeyBaseModel):
    body: EmailAuthBody


class EthSendRawTransactionResponse(TurnkeyBaseModel):
    activity: v1Activity
    transactionHash: str = Field(
        description="The transaction hash of the sent transaction"
    )


class EthSendRawTransactionBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    signedTransaction: str = Field(
        description="The raw, signed transaction to be sent."
    )
    caip2: str = Field(
        description="CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet)."
    )


class EthSendRawTransactionInput(TurnkeyBaseModel):
    body: EthSendRawTransactionBody


class EthSendTransactionResponse(TurnkeyBaseModel):
    activity: v1Activity
    sendTransactionStatusId: str = Field(
        description="The send_transaction_status ID associated with the transaction submission for sponsored transactions"
    )


class EthSendTransactionBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    from_: str = Field(
        alias="from",
        description="A wallet or private key address to sign with. This does not support private key IDs.",
    )
    sponsor: Optional[bool] = Field(
        default=None, description="Whether to sponsor this transaction via Gas Station."
    )
    caip2: str = Field(
        description="CAIP-2 chain ID (e.g., 'eip155:1' for Ethereum mainnet)."
    )
    to: str = Field(description="Recipient address as a hex string with 0x prefix.")
    value: Optional[str] = Field(
        default=None, description="Amount of native asset to send in wei."
    )
    data: Optional[str] = Field(
        default=None, description="Hex-encoded call data for contract interactions."
    )
    nonce: Optional[str] = Field(
        default=None,
        description="Transaction nonce, for EIP-1559 and Turnkey Gas Station authorizations.",
    )
    gasLimit: Optional[str] = Field(
        default=None,
        description="Maximum amount of gas to use for this transaction, for EIP-1559 transactions.",
    )
    maxFeePerGas: Optional[str] = Field(
        default=None,
        description="Maximum total fee per gas unit (base fee + priority fee) in wei. Required for non-sponsored (EIP-1559) transactions. Not used for sponsored transactions.",
    )
    maxPriorityFeePerGas: Optional[str] = Field(
        default=None,
        description="Maximum priority fee (tip) per gas unit in wei. Required for non-sponsored (EIP-1559) transactions. Not used for sponsored transactions.",
    )
    gasStationNonce: Optional[str] = Field(
        default=None,
        description="The gas station delegate contract nonce. Only used when sponsor=true. Include this if you want maximal security posture.",
    )


class EthSendTransactionInput(TurnkeyBaseModel):
    body: EthSendTransactionBody


class ExportPrivateKeyResponse(TurnkeyBaseModel):
    activity: v1Activity
    privateKeyId: str = Field(description="Unique identifier for a given Private Key.")
    exportBundle: str = Field(
        description="Export bundle containing a private key encrypted to the client's target public key."
    )


class ExportPrivateKeyBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    privateKeyId: str = Field(description="Unique identifier for a given Private Key.")
    targetPublicKey: str = Field(
        description="Client-side public key generated by the user, to which the export bundle will be encrypted."
    )


class ExportPrivateKeyInput(TurnkeyBaseModel):
    body: ExportPrivateKeyBody


class ExportWalletResponse(TurnkeyBaseModel):
    activity: v1Activity
    walletId: str = Field(description="Unique identifier for a given Wallet.")
    exportBundle: str = Field(
        description="Export bundle containing a wallet mnemonic + optional newline passphrase encrypted by the client's target public key."
    )


class ExportWalletBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    walletId: str = Field(description="Unique identifier for a given Wallet.")
    targetPublicKey: str = Field(
        description="Client-side public key generated by the user, to which the export bundle will be encrypted."
    )
    language: Optional[v1MnemonicLanguage] = Field(
        default=None,
        description="The language of the mnemonic to export. Defaults to English.",
    )


class ExportWalletInput(TurnkeyBaseModel):
    body: ExportWalletBody


class ExportWalletAccountResponse(TurnkeyBaseModel):
    activity: v1Activity
    address: str = Field(description="Address to identify Wallet Account.")
    exportBundle: str = Field(
        description="Export bundle containing a private key encrypted by the client's target public key."
    )


class ExportWalletAccountBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    address: str = Field(description="Address to identify Wallet Account.")
    targetPublicKey: str = Field(
        description="Client-side public key generated by the user, to which the export bundle will be encrypted."
    )


class ExportWalletAccountInput(TurnkeyBaseModel):
    body: ExportWalletAccountBody


class ImportPrivateKeyResponse(TurnkeyBaseModel):
    activity: v1Activity
    privateKeyId: str = Field(description="Unique identifier for a Private Key.")
    addresses: List[immutableactivityv1Address] = Field(
        description="A list of addresses."
    )


class ImportPrivateKeyBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    userId: str = Field(description="The ID of the User importing a Private Key.")
    privateKeyName: str = Field(description="Human-readable name for a Private Key.")
    encryptedBundle: str = Field(
        description="Bundle containing a raw private key encrypted to the enclave's target public key."
    )
    curve: v1Curve = Field(
        description="Cryptographic Curve used to generate a given Private Key."
    )
    addressFormats: List[v1AddressFormat] = Field(
        description="Cryptocurrency-specific formats for a derived address (e.g., Ethereum)."
    )


class ImportPrivateKeyInput(TurnkeyBaseModel):
    body: ImportPrivateKeyBody


class ImportWalletResponse(TurnkeyBaseModel):
    activity: v1Activity
    walletId: str = Field(description="Unique identifier for a Wallet.")
    addresses: List[str] = Field(description="A list of account addresses.")


class ImportWalletBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    userId: str = Field(description="The ID of the User importing a Wallet.")
    walletName: str = Field(description="Human-readable name for a Wallet.")
    encryptedBundle: str = Field(
        description="Bundle containing a wallet mnemonic encrypted to the enclave's target public key."
    )
    accounts: List[v1WalletAccountParams] = Field(
        description="A list of wallet Accounts."
    )


class ImportWalletInput(TurnkeyBaseModel):
    body: ImportWalletBody


class InitFiatOnRampResponse(TurnkeyBaseModel):
    activity: v1Activity
    onRampUrl: str = Field(description="Unique URL for a given fiat on-ramp flow.")
    onRampTransactionId: str = Field(
        description="Unique identifier used to retrieve transaction statuses for a given fiat on-ramp flow."
    )
    onRampUrlSignature: Optional[str] = Field(
        default=None,
        description="Optional signature of the MoonPay Widget URL. The signature is generated if the Init Fiat On Ramp intent includes the urlForSignature field. The signature can be used to initialize the MoonPay SDKs when URL signing is enabled for your project.",
    )


class InitFiatOnRampBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    onrampProvider: v1FiatOnRampProvider = Field(
        description="Enum to specifiy which on-ramp provider to use"
    )
    walletAddress: str = Field(
        description="Destination wallet address for the buy transaction."
    )
    network: v1FiatOnRampBlockchainNetwork = Field(
        description="Blockchain network to be used for the transaction, e.g., bitcoin, ethereum. Maps to MoonPay's network or Coinbase's defaultNetwork."
    )
    cryptoCurrencyCode: v1FiatOnRampCryptoCurrency = Field(
        description="Code for the cryptocurrency to be purchased, e.g., btc, eth. Maps to MoonPay's currencyCode or Coinbase's defaultAsset."
    )
    fiatCurrencyCode: Optional[v1FiatOnRampCurrency] = Field(
        default=None,
        description="Code for the fiat currency to be used in the transaction, e.g., USD, EUR.",
    )
    fiatCurrencyAmount: Optional[str] = Field(
        default=None,
        description="Specifies a preset fiat amount for the transaction, e.g., '100'. Must be greater than '20'. If not provided, the user will be prompted to enter an amount.",
    )
    paymentMethod: Optional[v1FiatOnRampPaymentMethod] = Field(
        default=None,
        description="Pre-selected payment method, e.g., CREDIT_DEBIT_CARD, APPLE_PAY. Validated against the chosen provider.",
    )
    countryCode: Optional[str] = Field(
        default=None,
        description="ISO 3166-1 two-digit country code for Coinbase representing the purchasing users country of residence, e.g., US, GB.",
    )
    countrySubdivisionCode: Optional[str] = Field(
        default=None,
        description="ISO 3166-2 two-digit country subdivision code for Coinbase representing the purchasing users subdivision of residence within their country, e.g. NY. Required if country_code=US.",
    )
    sandboxMode: Optional[bool] = Field(
        default=None,
        description="Optional flag to indicate whether to use the sandbox mode to simulate transactions for the on-ramp provider. Default is false.",
    )
    urlForSignature: Optional[str] = Field(
        default=None,
        description="Optional MoonPay Widget URL to sign when using MoonPay client SDKs with URL Signing enabled.",
    )


class InitFiatOnRampInput(TurnkeyBaseModel):
    body: InitFiatOnRampBody


class InitImportPrivateKeyResponse(TurnkeyBaseModel):
    activity: v1Activity
    importBundle: str = Field(
        description="Import bundle containing a public key and signature to use for importing client data."
    )


class InitImportPrivateKeyBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    userId: str = Field(description="The ID of the User importing a Private Key.")


class InitImportPrivateKeyInput(TurnkeyBaseModel):
    body: InitImportPrivateKeyBody


class InitImportWalletResponse(TurnkeyBaseModel):
    activity: v1Activity
    importBundle: str = Field(
        description="Import bundle containing a public key and signature to use for importing client data."
    )


class InitImportWalletBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    userId: str = Field(description="The ID of the User importing a Wallet.")


class InitImportWalletInput(TurnkeyBaseModel):
    body: InitImportWalletBody


class InitOtpResponse(TurnkeyBaseModel):
    activity: v1Activity
    otpId: str = Field(description="Unique identifier for an OTP authentication")


class InitOtpBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    otpType: str = Field(
        description="Whether to send OTP via SMS or email. Possible values: OTP_TYPE_SMS, OTP_TYPE_EMAIL"
    )
    contact: str = Field(description="Email or phone number to send the OTP code to")
    otpLength: Optional[int] = Field(
        default=None, description="Optional length of the OTP code. Default = 9"
    )
    appName: str = Field(
        description="The name of the application. This field is required and will be used in email notifications if an email template is not provided."
    )
    emailCustomization: Optional[v1EmailCustomizationParamsV2] = Field(
        default=None,
        description="Optional parameters for customizing emails. If not provided, the default email will be used.",
    )
    smsCustomization: Optional[v1SmsCustomizationParams] = Field(
        default=None,
        description="Optional parameters for customizing SMS message. If not provided, the default SMS message will be used.",
    )
    userIdentifier: Optional[str] = Field(
        default=None,
        description="Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address.",
    )
    sendFromEmailAddress: Optional[str] = Field(
        default=None,
        description="Optional custom email address from which to send the OTP email",
    )
    alphanumeric: Optional[bool] = Field(
        default=None,
        description="Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true",
    )
    sendFromEmailSenderName: Optional[str] = Field(
        default=None,
        description="Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'",
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the OTP is valid for. If not provided, a default of 5 minutes will be used. Maximum value is 600 seconds (10 minutes)",
    )
    replyToEmailAddress: Optional[str] = Field(
        default=None, description="Optional custom email address to use as reply-to"
    )


class InitOtpInput(TurnkeyBaseModel):
    body: InitOtpBody


class InitOtpAuthResponse(TurnkeyBaseModel):
    activity: v1Activity
    otpId: str = Field(description="Unique identifier for an OTP authentication")


class InitOtpAuthBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    otpType: str = Field(
        description="Whether to send OTP via SMS or email. Possible values: OTP_TYPE_SMS, OTP_TYPE_EMAIL"
    )
    contact: str = Field(description="Email or phone number to send the OTP code to")
    otpLength: Optional[int] = Field(
        default=None, description="Optional length of the OTP code. Default = 9"
    )
    appName: str = Field(
        description="The name of the application. This field is required and will be used in email notifications if an email template is not provided."
    )
    emailCustomization: Optional[v1EmailCustomizationParamsV2] = Field(
        default=None,
        description="Optional parameters for customizing emails. If not provided, the default email will be used.",
    )
    smsCustomization: Optional[v1SmsCustomizationParams] = Field(
        default=None,
        description="Optional parameters for customizing SMS message. If not provided, the default SMS message will be used.",
    )
    userIdentifier: Optional[str] = Field(
        default=None,
        description="Optional client-generated user identifier to enable per-user rate limiting for SMS auth. We recommend using a hash of the client-side IP address.",
    )
    sendFromEmailAddress: Optional[str] = Field(
        default=None,
        description="Optional custom email address from which to send the OTP email",
    )
    alphanumeric: Optional[bool] = Field(
        default=None,
        description="Optional flag to specify if the OTP code should be alphanumeric (Crockfords Base32). Default = true",
    )
    sendFromEmailSenderName: Optional[str] = Field(
        default=None,
        description="Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'",
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the OTP is valid for. If not provided, a default of 5 minutes will be used. Maximum value is 600 seconds (10 minutes)",
    )
    replyToEmailAddress: Optional[str] = Field(
        default=None, description="Optional custom email address to use as reply-to"
    )


class InitOtpAuthInput(TurnkeyBaseModel):
    body: InitOtpAuthBody


class InitUserEmailRecoveryResponse(TurnkeyBaseModel):
    activity: v1Activity
    userId: str = Field(description="Unique identifier for the user being recovered.")


class InitUserEmailRecoveryBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    email: str = Field(description="Email of the user starting recovery")
    targetPublicKey: str = Field(
        description="Client-side public key generated by the user, to which the recovery bundle will be encrypted."
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the recovery credential is valid for. If not provided, a default of 15 minutes will be used.",
    )
    emailCustomization: v1EmailAuthCustomizationParams = Field(
        description="Parameters for customizing emails. If not provided, the default email will be used. Note that `app_name` is required."
    )
    sendFromEmailAddress: Optional[str] = Field(
        default=None,
        description="Optional custom email address from which to send the OTP email",
    )
    sendFromEmailSenderName: Optional[str] = Field(
        default=None,
        description="Optional custom sender name for use with sendFromEmailAddress; if left empty, will default to 'Notifications'",
    )
    replyToEmailAddress: Optional[str] = Field(
        default=None, description="Optional custom email address to use as reply-to"
    )


class InitUserEmailRecoveryInput(TurnkeyBaseModel):
    body: InitUserEmailRecoveryBody


class OauthResponse(TurnkeyBaseModel):
    activity: v1Activity
    userId: str = Field(description="Unique identifier for the authenticating User.")
    apiKeyId: str = Field(description="Unique identifier for the created API key.")
    credentialBundle: str = Field(description="HPKE encrypted credential bundle")


class OauthBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    oidcToken: str = Field(description="Base64 encoded OIDC token")
    targetPublicKey: str = Field(
        description="Client-side public key generated by the user, to which the oauth bundle (credentials) will be encrypted."
    )
    apiKeyName: Optional[str] = Field(
        default=None,
        description="Optional human-readable name for an API Key. If none provided, default to Oauth - <Timestamp>",
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.",
    )
    invalidateExisting: Optional[bool] = Field(
        default=None,
        description="Invalidate all other previously generated Oauth API keys",
    )


class OauthInput(TurnkeyBaseModel):
    body: OauthBody


class Oauth2AuthenticateResponse(TurnkeyBaseModel):
    activity: v1Activity
    oidcToken: str = Field(
        description="Base64 encoded OIDC token issued by Turnkey to be used with the LoginWithOAuth activity"
    )


class Oauth2AuthenticateBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    oauth2CredentialId: str = Field(
        description="The OAuth 2.0 credential id whose client_id and client_secret will be used in the OAuth 2.0 flow"
    )
    authCode: str = Field(
        description="The auth_code provided by the OAuth 2.0 provider to the end user to be exchanged for a Bearer token in the OAuth 2.0 flow"
    )
    redirectUri: str = Field(
        description="The URI the user is redirected to after they have authenticated with the OAuth 2.0 provider"
    )
    codeVerifier: str = Field(
        description="The code verifier used by OAuth 2.0 PKCE providers"
    )
    nonce: Optional[str] = Field(
        default=None,
        description="An optional nonce used by the client to prevent replay/substitution of an ID token",
    )
    bearerTokenTargetPublicKey: Optional[str] = Field(
        default=None,
        description="An optional P256 public key to which, if provided, the bearer token will be encrypted and returned via the `encrypted_bearer_token` claim of the OIDC Token",
    )


class Oauth2AuthenticateInput(TurnkeyBaseModel):
    body: Oauth2AuthenticateBody


class OauthLoginResponse(TurnkeyBaseModel):
    activity: v1Activity
    session: str = Field(
        description="Signed JWT containing an expiry, public key, session type, user id, and organization id"
    )


class OauthLoginBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    oidcToken: str = Field(description="Base64 encoded OIDC token")
    publicKey: str = Field(
        description="Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the oidc token associated with this request"
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used.",
    )
    invalidateExisting: Optional[bool] = Field(
        default=None,
        description="Invalidate all other previously generated Login API keys",
    )


class OauthLoginInput(TurnkeyBaseModel):
    body: OauthLoginBody


class OtpAuthResponse(TurnkeyBaseModel):
    activity: v1Activity
    userId: str = Field(description="Unique identifier for the authenticating User.")
    apiKeyId: Optional[str] = Field(
        default=None, description="Unique identifier for the created API key."
    )
    credentialBundle: Optional[str] = Field(
        default=None, description="HPKE encrypted credential bundle"
    )


class OtpAuthBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    otpId: str = Field(
        description="ID representing the result of an init OTP activity."
    )
    otpCode: str = Field(description="OTP sent out to a user's contact (email or SMS)")
    targetPublicKey: str = Field(
        description="Client-side public key generated by the user, to which the OTP bundle (credentials) will be encrypted."
    )
    apiKeyName: Optional[str] = Field(
        default=None,
        description="Optional human-readable name for an API Key. If none provided, default to OTP Auth - <Timestamp>",
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the API key is valid for. If not provided, a default of 15 minutes will be used.",
    )
    invalidateExisting: Optional[bool] = Field(
        default=None,
        description="Invalidate all other previously generated OTP Auth API keys",
    )


class OtpAuthInput(TurnkeyBaseModel):
    body: OtpAuthBody


class OtpLoginResponse(TurnkeyBaseModel):
    activity: v1Activity
    session: str = Field(
        description="Signed JWT containing an expiry, public key, session type, user id, and organization id"
    )


class OtpLoginBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    verificationToken: str = Field(
        description="Signed JWT containing a unique id, expiry, verification type, contact"
    )
    publicKey: str = Field(
        description="Client-side public key generated by the user, which will be conditionally added to org data based on the validity of the verification token"
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used.",
    )
    invalidateExisting: Optional[bool] = Field(
        default=None,
        description="Invalidate all other previously generated Login API keys",
    )
    clientSignature: Optional[v1ClientSignature] = Field(
        default=None,
        description="Optional signature proving authorization for this login. The signature is over the verification token ID and the public key. Only required if a public key was provided during the verification step.",
    )


class OtpLoginInput(TurnkeyBaseModel):
    body: OtpLoginBody


class RecoverUserResponse(TurnkeyBaseModel):
    activity: v1Activity
    authenticatorId: List[str] = Field(description="ID of the authenticator created.")


class RecoverUserBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    authenticator: v1AuthenticatorParamsV2 = Field(
        description="The new authenticator to register."
    )
    userId: str = Field(
        description="Unique identifier for the user performing recovery."
    )


class RecoverUserInput(TurnkeyBaseModel):
    body: RecoverUserBody


class RejectActivityResponse(TurnkeyBaseModel):
    activity: v1Activity = Field(
        description="An action that can be taken within the Turnkey infrastructure."
    )


class RejectActivityBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    fingerprint: str = Field(description="An artifact verifying a User's action.")


class RejectActivityInput(TurnkeyBaseModel):
    body: RejectActivityBody


class RemoveOrganizationFeatureResponse(TurnkeyBaseModel):
    activity: v1Activity
    features: List[v1Feature] = Field(
        description="Resulting list of organization features."
    )


class RemoveOrganizationFeatureBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    name: v1FeatureName = Field(description="Name of the feature to remove")


class RemoveOrganizationFeatureInput(TurnkeyBaseModel):
    body: RemoveOrganizationFeatureBody


class SetOrganizationFeatureResponse(TurnkeyBaseModel):
    activity: v1Activity
    features: List[v1Feature] = Field(
        description="Resulting list of organization features."
    )


class SetOrganizationFeatureBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    name: v1FeatureName = Field(description="Name of the feature to set")
    value: str = Field(
        description="Optional value for the feature. Will override existing values if feature is already set."
    )


class SetOrganizationFeatureInput(TurnkeyBaseModel):
    body: SetOrganizationFeatureBody


class SignRawPayloadResponse(TurnkeyBaseModel):
    activity: v1Activity
    r: str = Field(description="Component of an ECSDA signature.")
    s: str = Field(description="Component of an ECSDA signature.")
    v: str = Field(description="Component of an ECSDA signature.")


class SignRawPayloadBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    signWith: str = Field(
        description="A Wallet account address, Private Key address, or Private Key identifier."
    )
    payload: str = Field(description="Raw unsigned payload to be signed.")
    encoding: v1PayloadEncoding = Field(
        description="Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8)."
    )
    hashFunction: v1HashFunction = Field(
        description="Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032."
    )


class SignRawPayloadInput(TurnkeyBaseModel):
    body: SignRawPayloadBody


class SignRawPayloadsResponse(TurnkeyBaseModel):
    activity: v1Activity
    signatures: Optional[List[v1SignRawPayloadResult]] = Field(default=None)


class SignRawPayloadsBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    signWith: str = Field(
        description="A Wallet account address, Private Key address, or Private Key identifier."
    )
    payloads: List[str] = Field(
        description="An array of raw unsigned payloads to be signed."
    )
    encoding: v1PayloadEncoding = Field(
        description="Encoding of the `payload` string. Turnkey uses this information to convert `payload` into bytes with the correct decoder (e.g. hex, utf8)."
    )
    hashFunction: v1HashFunction = Field(
        description="Hash function to apply to payload bytes before signing. This field must be set to HASH_FUNCTION_NOT_APPLICABLE for EdDSA/ed25519 signature requests; configurable payload hashing is not supported by RFC 8032."
    )


class SignRawPayloadsInput(TurnkeyBaseModel):
    body: SignRawPayloadsBody


class SignTransactionResponse(TurnkeyBaseModel):
    activity: v1Activity
    signedTransaction: str


class SignTransactionBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    signWith: str = Field(
        description="A Wallet account address, Private Key address, or Private Key identifier."
    )
    unsignedTransaction: str = Field(
        description="Raw unsigned transaction to be signed"
    )
    type: v1TransactionType


class SignTransactionInput(TurnkeyBaseModel):
    body: SignTransactionBody


class StampLoginResponse(TurnkeyBaseModel):
    activity: v1Activity
    session: str = Field(
        description="Signed JWT containing an expiry, public key, session type, user id, and organization id"
    )


class StampLoginBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    publicKey: str = Field(
        description="Client-side public key generated by the user, which will be conditionally added to org data based on the passkey stamp associated with this request"
    )
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the Session is valid for. If not provided, a default of 15 minutes will be used.",
    )
    invalidateExisting: Optional[bool] = Field(
        default=None,
        description="Invalidate all other previously generated Login API keys",
    )


class StampLoginInput(TurnkeyBaseModel):
    body: StampLoginBody


class UpdateFiatOnRampCredentialResponse(TurnkeyBaseModel):
    activity: v1Activity
    fiatOnRampCredentialId: str = Field(
        description="Unique identifier of the Fiat On-Ramp credential that was updated"
    )


class UpdateFiatOnRampCredentialBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    fiatOnrampCredentialId: str = Field(
        description="The ID of the fiat on-ramp credential to update"
    )
    onrampProvider: v1FiatOnRampProvider = Field(
        description="The fiat on-ramp provider"
    )
    projectId: Optional[str] = Field(
        default=None,
        description="Project ID for the on-ramp provider. Some providers, like Coinbase, require this additional identifier.",
    )
    publishableApiKey: str = Field(
        description="Publishable API key for the on-ramp provider"
    )
    encryptedSecretApiKey: str = Field(
        description="Secret API key for the on-ramp provider encrypted to our on-ramp encryption public key"
    )
    encryptedPrivateApiKey: Optional[str] = Field(
        default=None,
        description="Private API key for the on-ramp provider encrypted to our on-ramp encryption public key. Some providers, like Coinbase, require this additional key.",
    )


class UpdateFiatOnRampCredentialInput(TurnkeyBaseModel):
    body: UpdateFiatOnRampCredentialBody


class UpdateOauth2CredentialResponse(TurnkeyBaseModel):
    activity: v1Activity
    oauth2CredentialId: str = Field(
        description="Unique identifier of the OAuth 2.0 credential that was updated"
    )


class UpdateOauth2CredentialBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    oauth2CredentialId: str = Field(
        description="The ID of the OAuth 2.0 credential to update"
    )
    provider: v1Oauth2Provider = Field(description="The OAuth 2.0 provider")
    clientId: str = Field(description="The Client ID issued by the OAuth 2.0 provider")
    encryptedClientSecret: str = Field(
        description="The client secret issued by the OAuth 2.0 provider encrypted to the TLS Fetcher quorum key"
    )


class UpdateOauth2CredentialInput(TurnkeyBaseModel):
    body: UpdateOauth2CredentialBody


class UpdatePolicyResponse(TurnkeyBaseModel):
    activity: v1Activity
    policyId: str = Field(description="Unique identifier for a given Policy.")


class UpdatePolicyBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    policyId: str = Field(description="Unique identifier for a given Policy.")
    policyName: Optional[str] = Field(
        default=None, description="Human-readable name for a Policy."
    )
    policyEffect: Optional[v1Effect] = Field(
        default=None,
        description="The instruction to DENY or ALLOW an activity (optional).",
    )
    policyCondition: Optional[str] = Field(
        default=None,
        description="The condition expression that triggers the Effect (optional).",
    )
    policyConsensus: Optional[str] = Field(
        default=None,
        description="The consensus expression that triggers the Effect (optional).",
    )
    policyNotes: Optional[str] = Field(
        default=None, description="Accompanying notes for a Policy (optional)."
    )


class UpdatePolicyInput(TurnkeyBaseModel):
    body: UpdatePolicyBody


class UpdatePrivateKeyTagResponse(TurnkeyBaseModel):
    activity: v1Activity
    privateKeyTagId: str = Field(
        description="Unique identifier for a given Private Key Tag."
    )


class UpdatePrivateKeyTagBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    privateKeyTagId: str = Field(
        description="Unique identifier for a given Private Key Tag."
    )
    newPrivateKeyTagName: Optional[str] = Field(
        default=None,
        description="The new, human-readable name for the tag with the given ID.",
    )
    addPrivateKeyIds: List[str] = Field(
        description="A list of Private Keys IDs to add this tag to."
    )
    removePrivateKeyIds: List[str] = Field(
        description="A list of Private Key IDs to remove this tag from."
    )


class UpdatePrivateKeyTagInput(TurnkeyBaseModel):
    body: UpdatePrivateKeyTagBody


class UpdateRootQuorumResponse(TurnkeyBaseModel):
    activity: v1Activity


class UpdateRootQuorumBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    threshold: int = Field(
        description="The threshold of unique approvals to reach quorum."
    )
    userIds: List[str] = Field(
        description="The unique identifiers of users who comprise the quorum set."
    )


class UpdateRootQuorumInput(TurnkeyBaseModel):
    body: UpdateRootQuorumBody


class UpdateUserResponse(TurnkeyBaseModel):
    activity: v1Activity
    userId: str = Field(description="A User ID.")


class UpdateUserBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    userId: str = Field(description="Unique identifier for a given User.")
    userName: Optional[str] = Field(
        default=None, description="Human-readable name for a User."
    )
    userEmail: Optional[str] = Field(
        default=None, description="The user's email address."
    )
    userTagIds: Optional[List[str]] = Field(
        default=None,
        description="An updated list of User Tags to apply to this User. This field, if not needed, should be an empty array in your request body.",
    )
    userPhoneNumber: Optional[str] = Field(
        default=None,
        description="The user's phone number in E.164 format e.g. +13214567890",
    )


class UpdateUserInput(TurnkeyBaseModel):
    body: UpdateUserBody


class UpdateUserEmailResponse(TurnkeyBaseModel):
    activity: v1Activity
    userId: str = Field(
        description="Unique identifier of the User whose email was updated."
    )


class UpdateUserEmailBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    userId: str = Field(description="Unique identifier for a given User.")
    userEmail: str = Field(
        description="The user's email address. Setting this to an empty string will remove the user's email."
    )
    verificationToken: Optional[str] = Field(
        default=None,
        description="Signed JWT containing a unique id, expiry, verification type, contact",
    )


class UpdateUserEmailInput(TurnkeyBaseModel):
    body: UpdateUserEmailBody


class UpdateUserNameResponse(TurnkeyBaseModel):
    activity: v1Activity
    userId: str = Field(
        description="Unique identifier of the User whose name was updated."
    )


class UpdateUserNameBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    userId: str = Field(description="Unique identifier for a given User.")
    userName: str = Field(description="Human-readable name for a User.")


class UpdateUserNameInput(TurnkeyBaseModel):
    body: UpdateUserNameBody


class UpdateUserPhoneNumberResponse(TurnkeyBaseModel):
    activity: v1Activity
    userId: str = Field(
        description="Unique identifier of the User whose phone number was updated."
    )


class UpdateUserPhoneNumberBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    userId: str = Field(description="Unique identifier for a given User.")
    userPhoneNumber: str = Field(
        description="The user's phone number in E.164 format e.g. +13214567890. Setting this to an empty string will remove the user's phone number."
    )
    verificationToken: Optional[str] = Field(
        default=None,
        description="Signed JWT containing a unique id, expiry, verification type, contact",
    )


class UpdateUserPhoneNumberInput(TurnkeyBaseModel):
    body: UpdateUserPhoneNumberBody


class UpdateUserTagResponse(TurnkeyBaseModel):
    activity: v1Activity
    userTagId: str = Field(description="Unique identifier for a given User Tag.")


class UpdateUserTagBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    userTagId: str = Field(description="Unique identifier for a given User Tag.")
    newUserTagName: Optional[str] = Field(
        default=None,
        description="The new, human-readable name for the tag with the given ID.",
    )
    addUserIds: List[str] = Field(description="A list of User IDs to add this tag to.")
    removeUserIds: List[str] = Field(
        description="A list of User IDs to remove this tag from."
    )


class UpdateUserTagInput(TurnkeyBaseModel):
    body: UpdateUserTagBody


class UpdateWalletResponse(TurnkeyBaseModel):
    activity: v1Activity
    walletId: str = Field(description="A Wallet ID.")


class UpdateWalletBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    walletId: str = Field(description="Unique identifier for a given Wallet.")
    walletName: Optional[str] = Field(
        default=None, description="Human-readable name for a Wallet."
    )


class UpdateWalletInput(TurnkeyBaseModel):
    body: UpdateWalletBody


class VerifyOtpResponse(TurnkeyBaseModel):
    activity: v1Activity
    verificationToken: str = Field(
        description="Signed JWT containing a unique id, expiry, verification type, contact. Verification status of a user is updated when the token is consumed (in OTP_LOGIN requests)"
    )


class VerifyOtpBody(TurnkeyBaseModel):
    timestampMs: Optional[str] = None
    organizationId: Optional[str] = None
    otpId: str = Field(
        description="ID representing the result of an init OTP activity."
    )
    otpCode: str = Field(description="OTP sent out to a user's contact (email or SMS)")
    expirationSeconds: Optional[str] = Field(
        default=None,
        description="Expiration window (in seconds) indicating how long the verification token is valid for. If not provided, a default of 1 hour will be used. Maximum value is 86400 seconds (24 hours)",
    )
    publicKey: Optional[str] = Field(
        default=None,
        description="Client-side public key generated by the user, which will be added to the JWT response and verified in subsequent requests via a client proof signature",
    )


class VerifyOtpInput(TurnkeyBaseModel):
    body: VerifyOtpBody


class NOOPCodegenAnchorResponse(TurnkeyBaseModel):
    stamp: v1WebAuthnStamp
    tokenUsage: Optional[v1TokenUsage] = Field(default=None)


class TestRateLimitsResponse(TurnkeyBaseModel):
    pass


class TestRateLimitsBody(TurnkeyBaseModel):
    organizationId: Optional[str] = None
    isSetLimit: bool = Field(
        description="Whether or not to set a limit on this request."
    )
    limit: int = Field(
        description="Rate limit to set for org, if is_set_limit is set to true."
    )


class TestRateLimitsInput(TurnkeyBaseModel):
    body: TestRateLimitsBody
