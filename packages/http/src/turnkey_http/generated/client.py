# @generated by codegen. DO NOT EDIT BY HAND

import json
import time
from typing import Any, Dict, Optional
import requests
from turnkey_api_key_stamper import ApiKeyStamper
from turnkey_sdk_types.generated.types import *

TERMINAL_ACTIVITY_STATUSES = [
    "ACTIVITY_STATUS_COMPLETED",
    "ACTIVITY_STATUS_FAILED",
    "ACTIVITY_STATUS_CONSENSUS_NEEDED",
    "ACTIVITY_STATUS_REJECTED",
]


class TurnkeyClient:
    """Turnkey API HTTP client with auto-generated methods."""

    def __init__(
        self,
        base_url: str,
        stamper: ApiKeyStamper,
        organization_id: str,
        default_timeout: int = 30,
        polling_interval_ms: int = 1000,
        max_polling_retries: int = 3,
    ):
        """Initialize the Turnkey client.

        Args:
            base_url: Base URL for the Turnkey API
            stamper: API key stamper for authentication
            organization_id: Organization ID
            default_timeout: Default request timeout in seconds
            polling_interval_ms: Polling interval for command status in milliseconds
            max_polling_retries: Maximum number of polling retries
        """
        self.base_url = base_url.rstrip("/")
        self.stamper = stamper
        self.organization_id = organization_id
        self.default_timeout = default_timeout
        self.polling_interval_ms = polling_interval_ms
        self.max_polling_retries = max_polling_retries

    def _serialize_body(self, body: Any) -> str:
        """Serialize request body, handling Pydantic models recursively.

        Args:
            body: Request body (dict, Pydantic model, list, or primitive)

        Returns:
            JSON string
        """

        def serialize_value(value):
            """Recursively serialize values, converting Pydantic models to dicts."""
            if hasattr(value, "model_dump"):
                return value.model_dump(by_alias=True, exclude_none=True)
            elif isinstance(value, dict):
                return {k: serialize_value(v) for k, v in value.items()}
            elif isinstance(value, list):
                return [serialize_value(item) for item in value]
            else:
                return value

        serialized = serialize_value(body)
        return json.dumps(serialized)

    def _request(self, url: str, body: Dict[str, Any], response_type: type) -> Any:
        """Make a request to the Turnkey API.

        Args:
            url: Endpoint URL
            body: Request body
            response_type: Pydantic model class for response parsing

        Returns:
            Parsed response as Pydantic model

        Raises:
            Exception: If request fails
        """
        full_url = self.base_url + url
        body_str = self._serialize_body(body)
        stamp = self.stamper.stamp(body_str)

        headers = {
            stamp.stamp_header_name: stamp.stamp_header_value,
            "Content-Type": "application/json",
        }

        response = requests.post(
            full_url, headers=headers, data=body_str, timeout=self.default_timeout
        )

        if not response.ok:
            try:
                error_data = response.json()
                raise Exception(f"Turnkey API error: {error_data}")
            except ValueError:
                raise Exception(f"{response.status_code} {response.reason}")

        response_data = response.json()
        return response_type(**response_data)

    def _command(
        self, url: str, body: Dict[str, Any], result_key: str, response_type: type
    ) -> Any:
        """Execute a command and poll for completion.

        Args:
            url: Endpoint URL
            body: Request body
            result_key: Key to extract result from activity when completed
            response_type: Pydantic model class for response parsing

        Returns:
            Parsed response as Pydantic model with flattened result fields
        """
        # Make initial request
        response = self._request(url, body, response_type)

        # Check if we need to poll
        activity = response.activity

        if activity.status not in TERMINAL_ACTIVITY_STATUSES:
            # Poll for completion
            activity_id = activity.id
            attempts = 0

            while attempts < self.max_polling_retries:
                time.sleep(self.polling_interval_ms / 1000.0)

                # Poll activity status
                poll_response = self.get_activity({"activityId": activity_id})
                activity = poll_response.activity

                if activity.status in TERMINAL_ACTIVITY_STATUSES:
                    response = poll_response
                    break

                attempts += 1

        # If activity completed successfully, flatten result fields into response
        if (
            activity.status == "ACTIVITY_STATUS_COMPLETED"
            and hasattr(activity, "result")
            and activity.result
        ):
            result = activity.result
            # Get the versioned result key (e.g., 'createApiKeysResultV2')
            if hasattr(result, result_key):
                result_data = getattr(result, result_key)
                if result_data and hasattr(result_data, "model_dump"):
                    # Flatten result fields into response
                    result_dict = result_data.model_dump(
                        by_alias=True, exclude_none=True
                    )
                    response_dict = response.model_dump(
                        by_alias=True, exclude_none=True
                    )
                    response_dict.update(result_dict)
                    # Recreate response with flattened fields
                    response = response_type(**response_dict)

        return response

    def _activity_decision(
        self, url: str, body: Dict[str, Any], response_type: type
    ) -> Any:
        """Execute an activity decision.

        Args:
            url: Endpoint URL
            body: Request body
            response_type: Pydantic model class for response parsing

        Returns:
            Parsed response as Pydantic model
        """
        return self._request(url, body, response_type)

    def get_activity(self, input: TGetActivityBody) -> TGetActivityResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/get_activity", body, TGetActivityResponse
        )

    def get_api_key(self, input: TGetApiKeyBody) -> TGetApiKeyResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request("/public/v1/query/get_api_key", body, TGetApiKeyResponse)

    def get_api_keys(
        self, input: Optional[TGetApiKeysBody] = None
    ) -> TGetApiKeysResponse:
        if input is None:
            input_dict = {}
        else:
            # Convert Pydantic model to dict
            input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request("/public/v1/query/get_api_keys", body, TGetApiKeysResponse)

    def get_attestation_document(
        self, input: TGetAttestationDocumentBody
    ) -> TGetAttestationDocumentResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/get_attestation", body, TGetAttestationDocumentResponse
        )

    def get_authenticator(
        self, input: TGetAuthenticatorBody
    ) -> TGetAuthenticatorResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/get_authenticator", body, TGetAuthenticatorResponse
        )

    def get_authenticators(
        self, input: TGetAuthenticatorsBody
    ) -> TGetAuthenticatorsResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/get_authenticators", body, TGetAuthenticatorsResponse
        )

    def get_boot_proof(self, input: TGetBootProofBody) -> TGetBootProofResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/get_boot_proof", body, TGetBootProofResponse
        )

    def get_gas_usage(self, input: TGetGasUsageBody) -> TGetGasUsageResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/get_gas_usage", body, TGetGasUsageResponse
        )

    def get_latest_boot_proof(
        self, input: TGetLatestBootProofBody
    ) -> TGetLatestBootProofResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/get_latest_boot_proof", body, TGetLatestBootProofResponse
        )

    def get_nonces(self, input: TGetNoncesBody) -> TGetNoncesResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request("/public/v1/query/get_nonces", body, TGetNoncesResponse)

    def get_oauth2_credential(
        self, input: TGetOauth2CredentialBody
    ) -> TGetOauth2CredentialResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/get_oauth2_credential", body, TGetOauth2CredentialResponse
        )

    def get_oauth_providers(
        self, input: TGetOauthProvidersBody
    ) -> TGetOauthProvidersResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/get_oauth_providers", body, TGetOauthProvidersResponse
        )

    def get_on_ramp_transaction_status(
        self, input: TGetOnRampTransactionStatusBody
    ) -> TGetOnRampTransactionStatusResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/get_onramp_transaction_status",
            body,
            TGetOnRampTransactionStatusResponse,
        )

    def get_organization(
        self, input: Optional[TGetOrganizationBody] = None
    ) -> TGetOrganizationResponse:
        if input is None:
            input_dict = {}
        else:
            # Convert Pydantic model to dict
            input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/get_organization", body, TGetOrganizationResponse
        )

    def get_organization_configs(
        self, input: TGetOrganizationConfigsBody
    ) -> TGetOrganizationConfigsResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/get_organization_configs",
            body,
            TGetOrganizationConfigsResponse,
        )

    def get_policy(self, input: TGetPolicyBody) -> TGetPolicyResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request("/public/v1/query/get_policy", body, TGetPolicyResponse)

    def get_policy_evaluations(
        self, input: TGetPolicyEvaluationsBody
    ) -> TGetPolicyEvaluationsResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/get_policy_evaluations",
            body,
            TGetPolicyEvaluationsResponse,
        )

    def get_private_key(self, input: TGetPrivateKeyBody) -> TGetPrivateKeyResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/get_private_key", body, TGetPrivateKeyResponse
        )

    def get_send_transaction_status(
        self, input: TGetSendTransactionStatusBody
    ) -> TGetSendTransactionStatusResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/get_send_transaction_status",
            body,
            TGetSendTransactionStatusResponse,
        )

    def get_smart_contract_interface(
        self, input: TGetSmartContractInterfaceBody
    ) -> TGetSmartContractInterfaceResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/get_smart_contract_interface",
            body,
            TGetSmartContractInterfaceResponse,
        )

    def get_user(self, input: TGetUserBody) -> TGetUserResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request("/public/v1/query/get_user", body, TGetUserResponse)

    def get_wallet(self, input: TGetWalletBody) -> TGetWalletResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request("/public/v1/query/get_wallet", body, TGetWalletResponse)

    def get_wallet_account(
        self, input: TGetWalletAccountBody
    ) -> TGetWalletAccountResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/get_wallet_account", body, TGetWalletAccountResponse
        )

    def get_activities(
        self, input: Optional[TGetActivitiesBody] = None
    ) -> TGetActivitiesResponse:
        if input is None:
            input_dict = {}
        else:
            # Convert Pydantic model to dict
            input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/list_activities", body, TGetActivitiesResponse
        )

    def get_app_proofs(self, input: TGetAppProofsBody) -> TGetAppProofsResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/list_app_proofs", body, TGetAppProofsResponse
        )

    def list_fiat_on_ramp_credentials(
        self, input: TListFiatOnRampCredentialsBody
    ) -> TListFiatOnRampCredentialsResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/list_fiat_on_ramp_credentials",
            body,
            TListFiatOnRampCredentialsResponse,
        )

    def list_oauth2_credentials(
        self, input: TListOauth2CredentialsBody
    ) -> TListOauth2CredentialsResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/list_oauth2_credentials",
            body,
            TListOauth2CredentialsResponse,
        )

    def get_policies(
        self, input: Optional[TGetPoliciesBody] = None
    ) -> TGetPoliciesResponse:
        if input is None:
            input_dict = {}
        else:
            # Convert Pydantic model to dict
            input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/list_policies", body, TGetPoliciesResponse
        )

    def list_private_key_tags(
        self, input: TListPrivateKeyTagsBody
    ) -> TListPrivateKeyTagsResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/list_private_key_tags", body, TListPrivateKeyTagsResponse
        )

    def get_private_keys(
        self, input: Optional[TGetPrivateKeysBody] = None
    ) -> TGetPrivateKeysResponse:
        if input is None:
            input_dict = {}
        else:
            # Convert Pydantic model to dict
            input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/list_private_keys", body, TGetPrivateKeysResponse
        )

    def get_smart_contract_interfaces(
        self, input: TGetSmartContractInterfacesBody
    ) -> TGetSmartContractInterfacesResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/list_smart_contract_interfaces",
            body,
            TGetSmartContractInterfacesResponse,
        )

    def get_sub_org_ids(
        self, input: Optional[TGetSubOrgIdsBody] = None
    ) -> TGetSubOrgIdsResponse:
        if input is None:
            input_dict = {}
        else:
            # Convert Pydantic model to dict
            input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/list_suborgs", body, TGetSubOrgIdsResponse
        )

    def list_user_tags(
        self, input: Optional[TListUserTagsBody] = None
    ) -> TListUserTagsResponse:
        if input is None:
            input_dict = {}
        else:
            # Convert Pydantic model to dict
            input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/list_user_tags", body, TListUserTagsResponse
        )

    def get_users(self, input: Optional[TGetUsersBody] = None) -> TGetUsersResponse:
        if input is None:
            input_dict = {}
        else:
            # Convert Pydantic model to dict
            input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request("/public/v1/query/list_users", body, TGetUsersResponse)

    def get_verified_sub_org_ids(
        self, input: TGetVerifiedSubOrgIdsBody
    ) -> TGetVerifiedSubOrgIdsResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/list_verified_suborgs",
            body,
            TGetVerifiedSubOrgIdsResponse,
        )

    def get_wallet_accounts(
        self, input: TGetWalletAccountsBody
    ) -> TGetWalletAccountsResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/public/v1/query/list_wallet_accounts", body, TGetWalletAccountsResponse
        )

    def get_wallets(
        self, input: Optional[TGetWalletsBody] = None
    ) -> TGetWalletsResponse:
        if input is None:
            input_dict = {}
        else:
            # Convert Pydantic model to dict
            input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request("/public/v1/query/list_wallets", body, TGetWalletsResponse)

    def get_whoami(self, input: Optional[TGetWhoamiBody] = None) -> TGetWhoamiResponse:
        if input is None:
            input_dict = {}
        else:
            # Convert Pydantic model to dict
            input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request("/public/v1/query/whoami", body, TGetWhoamiResponse)

    def approve_activity(self, input: TApproveActivityBody) -> TApproveActivityResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_APPROVE_ACTIVITY",
        }

        return self._activity_decision(
            "/public/v1/submit/approve_activity", body, TApproveActivityResponse
        )

    def create_api_keys(self, input: TCreateApiKeysBody) -> TCreateApiKeysResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_CREATE_API_KEYS_V2",
        }

        return self._command(
            "/public/v1/submit/create_api_keys",
            body,
            "createApiKeysResult",
            TCreateApiKeysResponse,
        )

    def create_api_only_users(
        self, input: TCreateApiOnlyUsersBody
    ) -> TCreateApiOnlyUsersResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_CREATE_API_ONLY_USERS",
        }

        return self._command(
            "/public/v1/submit/create_api_only_users",
            body,
            "createApiOnlyUsersResult",
            TCreateApiOnlyUsersResponse,
        )

    def create_authenticators(
        self, input: TCreateAuthenticatorsBody
    ) -> TCreateAuthenticatorsResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2",
        }

        return self._command(
            "/public/v1/submit/create_authenticators",
            body,
            "createAuthenticatorsResult",
            TCreateAuthenticatorsResponse,
        )

    def create_fiat_on_ramp_credential(
        self, input: TCreateFiatOnRampCredentialBody
    ) -> TCreateFiatOnRampCredentialResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_CREATE_FIAT_ON_RAMP_CREDENTIAL",
        }

        return self._command(
            "/public/v1/submit/create_fiat_on_ramp_credential",
            body,
            "createFiatOnRampCredentialResult",
            TCreateFiatOnRampCredentialResponse,
        )

    def create_invitations(
        self, input: TCreateInvitationsBody
    ) -> TCreateInvitationsResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_CREATE_INVITATIONS",
        }

        return self._command(
            "/public/v1/submit/create_invitations",
            body,
            "createInvitationsResult",
            TCreateInvitationsResponse,
        )

    def create_oauth2_credential(
        self, input: TCreateOauth2CredentialBody
    ) -> TCreateOauth2CredentialResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_CREATE_OAUTH2_CREDENTIAL",
        }

        return self._command(
            "/public/v1/submit/create_oauth2_credential",
            body,
            "createOauth2CredentialResult",
            TCreateOauth2CredentialResponse,
        )

    def create_oauth_providers(
        self, input: TCreateOauthProvidersBody
    ) -> TCreateOauthProvidersResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_CREATE_OAUTH_PROVIDERS",
        }

        return self._command(
            "/public/v1/submit/create_oauth_providers",
            body,
            "createOauthProvidersResult",
            TCreateOauthProvidersResponse,
        )

    def create_policies(self, input: TCreatePoliciesBody) -> TCreatePoliciesResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_CREATE_POLICIES",
        }

        return self._command(
            "/public/v1/submit/create_policies",
            body,
            "createPoliciesResult",
            TCreatePoliciesResponse,
        )

    def create_policy(self, input: TCreatePolicyBody) -> TCreatePolicyResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_CREATE_POLICY_V3",
        }

        return self._command(
            "/public/v1/submit/create_policy",
            body,
            "createPolicyResult",
            TCreatePolicyResponse,
        )

    def create_private_key_tag(
        self, input: TCreatePrivateKeyTagBody
    ) -> TCreatePrivateKeyTagResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_CREATE_PRIVATE_KEY_TAG",
        }

        return self._command(
            "/public/v1/submit/create_private_key_tag",
            body,
            "createPrivateKeyTagResult",
            TCreatePrivateKeyTagResponse,
        )

    def create_private_keys(
        self, input: TCreatePrivateKeysBody
    ) -> TCreatePrivateKeysResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2",
        }

        return self._command(
            "/public/v1/submit/create_private_keys",
            body,
            "createPrivateKeysResultV2",
            TCreatePrivateKeysResponse,
        )

    def create_read_only_session(
        self, input: TCreateReadOnlySessionBody
    ) -> TCreateReadOnlySessionResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_CREATE_READ_ONLY_SESSION",
        }

        return self._command(
            "/public/v1/submit/create_read_only_session",
            body,
            "createReadOnlySessionResult",
            TCreateReadOnlySessionResponse,
        )

    def create_read_write_session(
        self, input: TCreateReadWriteSessionBody
    ) -> TCreateReadWriteSessionResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2",
        }

        return self._command(
            "/public/v1/submit/create_read_write_session",
            body,
            "createReadWriteSessionResultV2",
            TCreateReadWriteSessionResponse,
        )

    def create_smart_contract_interface(
        self, input: TCreateSmartContractInterfaceBody
    ) -> TCreateSmartContractInterfaceResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_CREATE_SMART_CONTRACT_INTERFACE",
        }

        return self._command(
            "/public/v1/submit/create_smart_contract_interface",
            body,
            "createSmartContractInterfaceResult",
            TCreateSmartContractInterfaceResponse,
        )

    def create_sub_organization(
        self, input: TCreateSubOrganizationBody
    ) -> TCreateSubOrganizationResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7",
        }

        return self._command(
            "/public/v1/submit/create_sub_organization",
            body,
            "createSubOrganizationResultV7",
            TCreateSubOrganizationResponse,
        )

    def create_user_tag(self, input: TCreateUserTagBody) -> TCreateUserTagResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_CREATE_USER_TAG",
        }

        return self._command(
            "/public/v1/submit/create_user_tag",
            body,
            "createUserTagResult",
            TCreateUserTagResponse,
        )

    def create_users(self, input: TCreateUsersBody) -> TCreateUsersResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_CREATE_USERS_V3",
        }

        return self._command(
            "/public/v1/submit/create_users",
            body,
            "createUsersResult",
            TCreateUsersResponse,
        )

    def create_wallet(self, input: TCreateWalletBody) -> TCreateWalletResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_CREATE_WALLET",
        }

        return self._command(
            "/public/v1/submit/create_wallet",
            body,
            "createWalletResult",
            TCreateWalletResponse,
        )

    def create_wallet_accounts(
        self, input: TCreateWalletAccountsBody
    ) -> TCreateWalletAccountsResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_CREATE_WALLET_ACCOUNTS",
        }

        return self._command(
            "/public/v1/submit/create_wallet_accounts",
            body,
            "createWalletAccountsResult",
            TCreateWalletAccountsResponse,
        )

    def delete_api_keys(self, input: TDeleteApiKeysBody) -> TDeleteApiKeysResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_DELETE_API_KEYS",
        }

        return self._command(
            "/public/v1/submit/delete_api_keys",
            body,
            "deleteApiKeysResult",
            TDeleteApiKeysResponse,
        )

    def delete_authenticators(
        self, input: TDeleteAuthenticatorsBody
    ) -> TDeleteAuthenticatorsResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_DELETE_AUTHENTICATORS",
        }

        return self._command(
            "/public/v1/submit/delete_authenticators",
            body,
            "deleteAuthenticatorsResult",
            TDeleteAuthenticatorsResponse,
        )

    def delete_fiat_on_ramp_credential(
        self, input: TDeleteFiatOnRampCredentialBody
    ) -> TDeleteFiatOnRampCredentialResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_DELETE_FIAT_ON_RAMP_CREDENTIAL",
        }

        return self._command(
            "/public/v1/submit/delete_fiat_on_ramp_credential",
            body,
            "deleteFiatOnRampCredentialResult",
            TDeleteFiatOnRampCredentialResponse,
        )

    def delete_invitation(
        self, input: TDeleteInvitationBody
    ) -> TDeleteInvitationResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_DELETE_INVITATION",
        }

        return self._command(
            "/public/v1/submit/delete_invitation",
            body,
            "deleteInvitationResult",
            TDeleteInvitationResponse,
        )

    def delete_oauth2_credential(
        self, input: TDeleteOauth2CredentialBody
    ) -> TDeleteOauth2CredentialResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_DELETE_OAUTH2_CREDENTIAL",
        }

        return self._command(
            "/public/v1/submit/delete_oauth2_credential",
            body,
            "deleteOauth2CredentialResult",
            TDeleteOauth2CredentialResponse,
        )

    def delete_oauth_providers(
        self, input: TDeleteOauthProvidersBody
    ) -> TDeleteOauthProvidersResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_DELETE_OAUTH_PROVIDERS",
        }

        return self._command(
            "/public/v1/submit/delete_oauth_providers",
            body,
            "deleteOauthProvidersResult",
            TDeleteOauthProvidersResponse,
        )

    def delete_policies(self, input: TDeletePoliciesBody) -> TDeletePoliciesResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_DELETE_POLICIES",
        }

        return self._command(
            "/public/v1/submit/delete_policies",
            body,
            "deletePoliciesResult",
            TDeletePoliciesResponse,
        )

    def delete_policy(self, input: TDeletePolicyBody) -> TDeletePolicyResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_DELETE_POLICY",
        }

        return self._command(
            "/public/v1/submit/delete_policy",
            body,
            "deletePolicyResult",
            TDeletePolicyResponse,
        )

    def delete_private_key_tags(
        self, input: TDeletePrivateKeyTagsBody
    ) -> TDeletePrivateKeyTagsResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_DELETE_PRIVATE_KEY_TAGS",
        }

        return self._command(
            "/public/v1/submit/delete_private_key_tags",
            body,
            "deletePrivateKeyTagsResult",
            TDeletePrivateKeyTagsResponse,
        )

    def delete_private_keys(
        self, input: TDeletePrivateKeysBody
    ) -> TDeletePrivateKeysResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_DELETE_PRIVATE_KEYS",
        }

        return self._command(
            "/public/v1/submit/delete_private_keys",
            body,
            "deletePrivateKeysResult",
            TDeletePrivateKeysResponse,
        )

    def delete_smart_contract_interface(
        self, input: TDeleteSmartContractInterfaceBody
    ) -> TDeleteSmartContractInterfaceResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_DELETE_SMART_CONTRACT_INTERFACE",
        }

        return self._command(
            "/public/v1/submit/delete_smart_contract_interface",
            body,
            "deleteSmartContractInterfaceResult",
            TDeleteSmartContractInterfaceResponse,
        )

    def delete_sub_organization(
        self, input: TDeleteSubOrganizationBody
    ) -> TDeleteSubOrganizationResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_DELETE_SUB_ORGANIZATION",
        }

        return self._command(
            "/public/v1/submit/delete_sub_organization",
            body,
            "deleteSubOrganizationResult",
            TDeleteSubOrganizationResponse,
        )

    def delete_user_tags(self, input: TDeleteUserTagsBody) -> TDeleteUserTagsResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_DELETE_USER_TAGS",
        }

        return self._command(
            "/public/v1/submit/delete_user_tags",
            body,
            "deleteUserTagsResult",
            TDeleteUserTagsResponse,
        )

    def delete_users(self, input: TDeleteUsersBody) -> TDeleteUsersResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_DELETE_USERS",
        }

        return self._command(
            "/public/v1/submit/delete_users",
            body,
            "deleteUsersResult",
            TDeleteUsersResponse,
        )

    def delete_wallet_accounts(
        self, input: TDeleteWalletAccountsBody
    ) -> TDeleteWalletAccountsResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_DELETE_WALLET_ACCOUNTS",
        }

        return self._command(
            "/public/v1/submit/delete_wallet_accounts",
            body,
            "deleteWalletAccountsResult",
            TDeleteWalletAccountsResponse,
        )

    def delete_wallets(self, input: TDeleteWalletsBody) -> TDeleteWalletsResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_DELETE_WALLETS",
        }

        return self._command(
            "/public/v1/submit/delete_wallets",
            body,
            "deleteWalletsResult",
            TDeleteWalletsResponse,
        )

    def email_auth(self, input: TEmailAuthBody) -> TEmailAuthResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_EMAIL_AUTH_V3",
        }

        return self._command(
            "/public/v1/submit/email_auth", body, "emailAuthResult", TEmailAuthResponse
        )

    def eth_send_raw_transaction(
        self, input: TEthSendRawTransactionBody
    ) -> TEthSendRawTransactionResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_ETH_SEND_RAW_TRANSACTION",
        }

        return self._command(
            "/public/v1/submit/eth_send_raw_transaction",
            body,
            "ethSendRawTransactionResult",
            TEthSendRawTransactionResponse,
        )

    def eth_send_transaction(
        self, input: TEthSendTransactionBody
    ) -> TEthSendTransactionResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_ETH_SEND_TRANSACTION",
        }

        return self._command(
            "/public/v1/submit/eth_send_transaction",
            body,
            "ethSendTransactionResult",
            TEthSendTransactionResponse,
        )

    def export_private_key(
        self, input: TExportPrivateKeyBody
    ) -> TExportPrivateKeyResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_EXPORT_PRIVATE_KEY",
        }

        return self._command(
            "/public/v1/submit/export_private_key",
            body,
            "exportPrivateKeyResult",
            TExportPrivateKeyResponse,
        )

    def export_wallet(self, input: TExportWalletBody) -> TExportWalletResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_EXPORT_WALLET",
        }

        return self._command(
            "/public/v1/submit/export_wallet",
            body,
            "exportWalletResult",
            TExportWalletResponse,
        )

    def export_wallet_account(
        self, input: TExportWalletAccountBody
    ) -> TExportWalletAccountResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT",
        }

        return self._command(
            "/public/v1/submit/export_wallet_account",
            body,
            "exportWalletAccountResult",
            TExportWalletAccountResponse,
        )

    def import_private_key(
        self, input: TImportPrivateKeyBody
    ) -> TImportPrivateKeyResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_IMPORT_PRIVATE_KEY",
        }

        return self._command(
            "/public/v1/submit/import_private_key",
            body,
            "importPrivateKeyResult",
            TImportPrivateKeyResponse,
        )

    def import_wallet(self, input: TImportWalletBody) -> TImportWalletResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_IMPORT_WALLET",
        }

        return self._command(
            "/public/v1/submit/import_wallet",
            body,
            "importWalletResult",
            TImportWalletResponse,
        )

    def init_fiat_on_ramp(self, input: TInitFiatOnRampBody) -> TInitFiatOnRampResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_INIT_FIAT_ON_RAMP",
        }

        return self._command(
            "/public/v1/submit/init_fiat_on_ramp",
            body,
            "initFiatOnRampResult",
            TInitFiatOnRampResponse,
        )

    def init_import_private_key(
        self, input: TInitImportPrivateKeyBody
    ) -> TInitImportPrivateKeyResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_INIT_IMPORT_PRIVATE_KEY",
        }

        return self._command(
            "/public/v1/submit/init_import_private_key",
            body,
            "initImportPrivateKeyResult",
            TInitImportPrivateKeyResponse,
        )

    def init_import_wallet(
        self, input: TInitImportWalletBody
    ) -> TInitImportWalletResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_INIT_IMPORT_WALLET",
        }

        return self._command(
            "/public/v1/submit/init_import_wallet",
            body,
            "initImportWalletResult",
            TInitImportWalletResponse,
        )

    def init_otp(self, input: TInitOtpBody) -> TInitOtpResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_INIT_OTP_V2",
        }

        return self._command(
            "/public/v1/submit/init_otp", body, "initOtpResult", TInitOtpResponse
        )

    def init_otp_auth(self, input: TInitOtpAuthBody) -> TInitOtpAuthResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_INIT_OTP_AUTH_V3",
        }

        return self._command(
            "/public/v1/submit/init_otp_auth",
            body,
            "initOtpAuthResultV2",
            TInitOtpAuthResponse,
        )

    def init_user_email_recovery(
        self, input: TInitUserEmailRecoveryBody
    ) -> TInitUserEmailRecoveryResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY_V2",
        }

        return self._command(
            "/public/v1/submit/init_user_email_recovery",
            body,
            "initUserEmailRecoveryResult",
            TInitUserEmailRecoveryResponse,
        )

    def oauth(self, input: TOauthBody) -> TOauthResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_OAUTH",
        }

        return self._command(
            "/public/v1/submit/oauth", body, "oauthResult", TOauthResponse
        )

    def oauth2_authenticate(
        self, input: TOauth2AuthenticateBody
    ) -> TOauth2AuthenticateResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_OAUTH2_AUTHENTICATE",
        }

        return self._command(
            "/public/v1/submit/oauth2_authenticate",
            body,
            "oauth2AuthenticateResult",
            TOauth2AuthenticateResponse,
        )

    def oauth_login(self, input: TOauthLoginBody) -> TOauthLoginResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_OAUTH_LOGIN",
        }

        return self._command(
            "/public/v1/submit/oauth_login",
            body,
            "oauthLoginResult",
            TOauthLoginResponse,
        )

    def otp_auth(self, input: TOtpAuthBody) -> TOtpAuthResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_OTP_AUTH",
        }

        return self._command(
            "/public/v1/submit/otp_auth", body, "otpAuthResult", TOtpAuthResponse
        )

    def otp_login(self, input: TOtpLoginBody) -> TOtpLoginResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_OTP_LOGIN",
        }

        return self._command(
            "/public/v1/submit/otp_login", body, "otpLoginResult", TOtpLoginResponse
        )

    def recover_user(self, input: TRecoverUserBody) -> TRecoverUserResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_RECOVER_USER",
        }

        return self._command(
            "/public/v1/submit/recover_user",
            body,
            "recoverUserResult",
            TRecoverUserResponse,
        )

    def reject_activity(self, input: TRejectActivityBody) -> TRejectActivityResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_REJECT_ACTIVITY",
        }

        return self._activity_decision(
            "/public/v1/submit/reject_activity", body, TRejectActivityResponse
        )

    def remove_organization_feature(
        self, input: TRemoveOrganizationFeatureBody
    ) -> TRemoveOrganizationFeatureResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_REMOVE_ORGANIZATION_FEATURE",
        }

        return self._command(
            "/public/v1/submit/remove_organization_feature",
            body,
            "removeOrganizationFeatureResult",
            TRemoveOrganizationFeatureResponse,
        )

    def set_organization_feature(
        self, input: TSetOrganizationFeatureBody
    ) -> TSetOrganizationFeatureResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_SET_ORGANIZATION_FEATURE",
        }

        return self._command(
            "/public/v1/submit/set_organization_feature",
            body,
            "setOrganizationFeatureResult",
            TSetOrganizationFeatureResponse,
        )

    def sign_raw_payload(self, input: TSignRawPayloadBody) -> TSignRawPayloadResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2",
        }

        return self._command(
            "/public/v1/submit/sign_raw_payload",
            body,
            "signRawPayloadResult",
            TSignRawPayloadResponse,
        )

    def sign_raw_payloads(
        self, input: TSignRawPayloadsBody
    ) -> TSignRawPayloadsResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_SIGN_RAW_PAYLOADS",
        }

        return self._command(
            "/public/v1/submit/sign_raw_payloads",
            body,
            "signRawPayloadsResult",
            TSignRawPayloadsResponse,
        )

    def sign_transaction(self, input: TSignTransactionBody) -> TSignTransactionResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_SIGN_TRANSACTION_V2",
        }

        return self._command(
            "/public/v1/submit/sign_transaction",
            body,
            "signTransactionResult",
            TSignTransactionResponse,
        )

    def stamp_login(self, input: TStampLoginBody) -> TStampLoginResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_STAMP_LOGIN",
        }

        return self._command(
            "/public/v1/submit/stamp_login",
            body,
            "stampLoginResult",
            TStampLoginResponse,
        )

    def update_fiat_on_ramp_credential(
        self, input: TUpdateFiatOnRampCredentialBody
    ) -> TUpdateFiatOnRampCredentialResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_UPDATE_FIAT_ON_RAMP_CREDENTIAL",
        }

        return self._command(
            "/public/v1/submit/update_fiat_on_ramp_credential",
            body,
            "updateFiatOnRampCredentialResult",
            TUpdateFiatOnRampCredentialResponse,
        )

    def update_oauth2_credential(
        self, input: TUpdateOauth2CredentialBody
    ) -> TUpdateOauth2CredentialResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_UPDATE_OAUTH2_CREDENTIAL",
        }

        return self._command(
            "/public/v1/submit/update_oauth2_credential",
            body,
            "updateOauth2CredentialResult",
            TUpdateOauth2CredentialResponse,
        )

    def update_policy(self, input: TUpdatePolicyBody) -> TUpdatePolicyResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_UPDATE_POLICY_V2",
        }

        return self._command(
            "/public/v1/submit/update_policy",
            body,
            "updatePolicyResultV2",
            TUpdatePolicyResponse,
        )

    def update_private_key_tag(
        self, input: TUpdatePrivateKeyTagBody
    ) -> TUpdatePrivateKeyTagResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_UPDATE_PRIVATE_KEY_TAG",
        }

        return self._command(
            "/public/v1/submit/update_private_key_tag",
            body,
            "updatePrivateKeyTagResult",
            TUpdatePrivateKeyTagResponse,
        )

    def update_root_quorum(
        self, input: TUpdateRootQuorumBody
    ) -> TUpdateRootQuorumResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_UPDATE_ROOT_QUORUM",
        }

        return self._command(
            "/public/v1/submit/update_root_quorum",
            body,
            "updateRootQuorumResult",
            TUpdateRootQuorumResponse,
        )

    def update_user(self, input: TUpdateUserBody) -> TUpdateUserResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_UPDATE_USER",
        }

        return self._command(
            "/public/v1/submit/update_user",
            body,
            "updateUserResult",
            TUpdateUserResponse,
        )

    def update_user_email(
        self, input: TUpdateUserEmailBody
    ) -> TUpdateUserEmailResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_UPDATE_USER_EMAIL",
        }

        return self._command(
            "/public/v1/submit/update_user_email",
            body,
            "updateUserEmailResult",
            TUpdateUserEmailResponse,
        )

    def update_user_name(self, input: TUpdateUserNameBody) -> TUpdateUserNameResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_UPDATE_USER_NAME",
        }

        return self._command(
            "/public/v1/submit/update_user_name",
            body,
            "updateUserNameResult",
            TUpdateUserNameResponse,
        )

    def update_user_phone_number(
        self, input: TUpdateUserPhoneNumberBody
    ) -> TUpdateUserPhoneNumberResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_UPDATE_USER_PHONE_NUMBER",
        }

        return self._command(
            "/public/v1/submit/update_user_phone_number",
            body,
            "updateUserPhoneNumberResult",
            TUpdateUserPhoneNumberResponse,
        )

    def update_user_tag(self, input: TUpdateUserTagBody) -> TUpdateUserTagResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_UPDATE_USER_TAG",
        }

        return self._command(
            "/public/v1/submit/update_user_tag",
            body,
            "updateUserTagResult",
            TUpdateUserTagResponse,
        )

    def update_wallet(self, input: TUpdateWalletBody) -> TUpdateWalletResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_UPDATE_WALLET",
        }

        return self._command(
            "/public/v1/submit/update_wallet",
            body,
            "updateWalletResult",
            TUpdateWalletResponse,
        )

    def verify_otp(self, input: TVerifyOtpBody) -> TVerifyOtpResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)
        timestamp_ms = input_dict.pop("timestampMs", str(int(time.time() * 1000)))

        body = {
            "parameters": input_dict,
            "organizationId": organization_id,
            "timestampMs": timestamp_ms,
            "type": "ACTIVITY_TYPE_VERIFY_OTP",
        }

        return self._command(
            "/public/v1/submit/verify_otp", body, "verifyOtpResult", TVerifyOtpResponse
        )

    def test_rate_limits(self, input: TTestRateLimitsBody) -> TTestRateLimitsResponse:
        # Convert Pydantic model to dict
        input_dict = input.model_dump(by_alias=True, exclude_none=True)

        organization_id = input_dict.pop("organizationId", self.organization_id)

        body = {"organizationId": organization_id, **input_dict}

        return self._request(
            "/tkhq/api/v1/test_rate_limits", body, TTestRateLimitsResponse
        )
